[[header]]
:description: RISC-V N-Trace (Nexus-based Trace)
:company: RISC-V.org
:revdate:  Sep 10, 2023
:revnumber: 1.0.0_rc9
:revremark: Frozen state (before Architecture Committee review)
:url-riscv: http://riscv.org
:doctype: book
:preface-title: Preamble
:colophon:
:appendix-caption: Appendix
:title-logo-image: image:docs-resources/images/risc-v_logo.svg[pdfwidth=3.25in,align=center]
// Settings:
:experimental:
:reproducible:
:WaveDromEditorApp: wavedrom-cli
:imagesoutdir: images
:icons: font
:lang: en
:listing-caption: Listing
:sectnums:
:sectnumlevels: 5
:toclevels: 5
:toc: left
:source-highlighter: pygments
ifdef::backend-pdf[]
:source-highlighter: coderay
endif::[]
:data-uri:
:hide-uri-scheme:
:stem: latexmath
:footnote:
:xrefstyle: short
:bibtex-file: example.bib
:bibtex-order: alphabetical
:bibtex-style: apa

= RISC-V N-Trace (Nexus-based Trace) Specification
RISC-V N-Trace Task Group

// Preamble
[WARNING]
.This document is in the link:http://riscv.org/spec-state[Frozen state]
====
Change is extremely unlikely.
====

[preface]
== Change Log

PDF generated on: {localdatetime}

=== Version 1.0.0_rc9
* 2023-09-10
** The pre-public review version (older history removed)

[Preface]
== Copyright and license information

This RISC-V N-Trace (Nexus-based Trace) specification is © 2019-2023 RISC-V international

This document is released under a Creative Commons Attribution 4.0
International License. +
https://creativecommons.org/licenses/by/4.0/.

Please cite as: “RISC-V N-Trace (Nexus-based Trace) Specification",  RISC-V International

[Preface]
== Contributors
Key contributors to RISC-V N-Trace (Nexus-based Trace) specification in alphabetical order: +

Bruce Ableidinger (SiFive) => Initial SiFive donation, reviews +
Robert Chyla (IAR, SiFive) => Most topics, editing, publishing +
Ernie Edgar (SiFive) => Initial SiFive donation, reviews +
Jay Gamoneda (NXP) => Reviews +
Markus Goehrle (Lauterbach) => Reviews, updates +
Nino Vidovic (Segger) => Reviews

== Introduction to N-Trace

N-Trace specification provides specification of complete, end-to-end, trace system for RISC-V cores, harts and SoC/MCU designs. N-Trace standard is based on a well established Nexus IEEE 5001 trace standard.

This document is describing N-Trace Trace Encoder and Messaging Protocol version 1.0. It serves multiple audiences:

* N-Trace encoder logic/IP developers.
* Validation teams seeking validation of N-Trace trace implementation.
* Debug and trace tools (probes, decoders, analyzers) developers.

During development of this specification the following key design decisions were made:

* Trace ingress port (connection between hart and trace sub-system) is identical as in ratified E-Trace specification. No other parts of E-Trace specification are used by N-Trace (E-Trace protocol just defines different format of trace packets).

* N-Trace messages are kept compatible with the original Nexus specification
** An appropriate subset applicable to RISC-V was selected.
** Subset was limited to program trace only, but it will be followed by Nexus compliant data and bus trace.
** Handful of Nexus-compatible extensions allowing better trace compression are defined.

* Trace control layer defined in Nexus specification was message based and it would be hard to adopt it. Instead, donated by SiFive, a proven working control layer specification was adopted and extended. It assured that in the moment of N-Trace ratification most trace tool vendors will be able to provide full support with minimal changes in trace control software.

** This control specification was agreed to be shared with ratified E-Trace specification, so the RISC-V trace sub-system will be more unified and easier to understand and handle.

* Trace connectors defined by Nexus were debug oriented, so could not be easily used. Instead, industry standard MIPI-compliant connectors (MIPI20 and Mictor-38) which are supported by all debug and trace probes for a long time are used (with small, generic extensions).
** These connectors are pure extensions of connectors defined in ratified RISC-V Debug Specification.

NOTE: This specification does NOT require developers (both IP developers and trace tool developers) to become familiar with any other documentation besides PDF files provided below. These PDF files are providing links to original PDF files (Nexus Specification, SiFive Control Layer Donation, MIPI Connectors White Paper) as references.

=== Related Specifications

This document provides reference to separated documents developed together as part of RISC-V N-Trace Specification:

[#RISC-V_Trace_Control_Interface]
* https://github.com/riscv-non-isa/tg-nexus-trace/tree/master/pdfs/RISC-V-Trace-Control-Interface.pdf[RISC-V Trace Control Interface Specification] - Defines RISC-V trace control interface.
* https://github.com/riscv-non-isa/tg-nexus-trace/tree/master/pdfs/RISC-V-Trace-Connectors.pdf[RISC-V Trace Connectors Specification] - Defines RISC-V trace connectors (for external trace probes).

[#E-Trace_Specification]
* https://github.com/riscv-non-isa/riscv-trace-spec/releases/download/v2.0rc2/riscv-trace-spec.pdf[Efficient Trace for RISC-V] Specification - Defines RISC-V Trace Ingress Port signals (chapter *4 Instruction Trace Interface*).
** At the moment of this writing this is version 2.0 (ratified May 5-th 2022).
** In future ingress port may be defined in separated document - in such a a case reference to E-Trace specification will not be necessary (both N-Trace and E-Trace should reference same RISC-V Trace Ingress Port specification).

Document `Specification of RISC-V Trace Control Interface` is intended to be shared with ratified `Efficient Trace for RISC-V Specification (v2.0.0)` document.

NOTE: Above links are pointing into github repositories, as there is no consistent storage or naming conventions for ratified RISC-V specifications.

////
This comment is taken AS-IS from iommu_intro.adoc file
Please in ditaa figures don't use the minus key '-' in your keyboard when
typing text (like 'non-privileged' in the figure below).
'-' is a special character that is used by ditaa to draw lines, not text.
Instead use a different unicode character that looks similar.
The figure below uses the unicode character with code U+2212 instead of the '-'
character of your keyboard (which has the unicode code U+002B).
Note that in your editor both probably look the same, but when rendered by
ditaa/asciidoc the '-' from your keyboard is used to draw a line, while the
alternative looks as a minus symbol.
If you don't know how to type an unicode character in your editor you might
simply copy the '−' character in the 'non−privileged' word from the drawing
below.
Other potential unicode characters might be found in the following links:
- https://www.compart.com/en/unicode/category/Pd
- https://www.compart.com/en/unicode/bidiclass/ES
////

=== Trace Encoder Interfaces

Diagram below shows only a single RISC-V hart. In a system with multiple cores/harts the *Trace Ingress Port*, *Trace Encoder Control* and *Trace Encoder* blocks should be replicated for each hart.
The main *Trace Control Layer* controlling other (shared) components in the trace system is not replicated.

[[fig:trace-encoder-interfaces]]
.Trace Encoder Interfaces
["ditaa",shadows=true, separation=false, fontsize: 14]
....

                      +--- Control register
                      |    read/write
                      |
      +----------+    V    +---------------------+     
      |          |         | Trace Control Layer |
      | Debug    |<=======>|                     |-----> Control of other
      | Module   |         |  +-------------+    |       trace components 
      |          |<------->|  |Trace Encoder|    |       (transport/storage)
      +----------+    ^    +--|  Control    |----+
            ^         |       +-------------+
            | <--- triggers,      ^
            |      stall etc.     |
            V                     | <------ Encoder control/status signals
+----------------+                |         (bits/fields in registers)
| RISC−V Hart    |                V
|          +---------+       +---------+     
|          |  Trace  |       |  Trace  |                To N−Trace transport
|          | Ingress |======>| Encoder |==============> for multiplexing/
|          |  Port   |   ^   |         |       ^        storage/export
|          +---------+   |   +---------+       |
|                |       |                     +--- Encoded trace messages
|                |       |   Ingress port           for single hart (with
+----------------+       +-- signals defined        optional source ID)
                             in E−Trace spec
....

=== Definitions and Terminology

[#Terms Used In This Specification]
.Terms Used In This Specification
[cols="25%,75%",options="header",]
|======================================================================================================
|Term| Definition
|Message|N-Trace messages are sequences of bytes. First byte of every message includes the TCODE field, which defines the type of information carried in the message and its format. When messages are transmitted or stored a protocol, described in <<N-Trace Transmission Protocol,N-Trace Transmission Protocol>> chapter, defines the start and the end of each message.

|Field| A field is a distinct piece of the information contained within a message, and messages may contain one or more fields (in addition to the first TCODE field). Fields can be either of fixed-length or variable-length. Several fields may be packet into single byte and single field may span across multiple bytes. Definitions of all fields can be found in <<Fields in Messages,Fields in Messages>> chapter.

|Variable-length Field|Specifying that a field is variable-length (*Var* used as field size definition) means that the message must contain the field, but that the field's size may vary from a minimum of 1 bit. When messages are transferred or stored, variable-length fields must end on a byte boundary. If necessary, they must zero-fill bit positions beyond the highest order bit of the variable-length data. Because variable-length fields may be of different lengths in messages of the same type, when messages are transmitted or stored a protocol, described in <<N-Trace Transmission Protocol,N-Trace Transmission Protocol>> chapter, defines the end of each variable-length field.

|Configurable Field|Configurable field (*Cfg* used as field size) means that existence and size of this field depends on some configuration setting. See <<N-Trace Specific Trace Controls,N-Trace Specific Trace Controls>> chapter for details.
|N-Trace| Nexus Based Trace for RISC-V (as defined by this specification).
|E-Trace| Efficient Trace for RISC-V (as defined by <<E-Trace_Specification,E-Trace Specification>>).
|Unconditional Jump|On RISC-V ISA all jump instructions are always unconditional, but these two words are always used to avoid any confusions with the term 'branch' used by the Nexus standard. The two main sub-categories of unconditional jumps that are relevant for tracing are: direct unconditional jump and indirect unconditional jump.
|Direct Conditional Branch|On RISC-V ISA all branch instructions are always direct and conditional (and also relative), but these three words are always used together to avoid confusions with the term 'branch' used by the Nexus standard.
|======================================================================================================

== Trace Ingress Port

N-Trace is using the same ingress port as specified in <<E-Trace_Specification,E-Trace Specification>> (chapter *4 Instruction Trace Interface*).

* As this specification does not define the data trace yet, sub-chapters *4.3 Data Trace Interface requirements* and *4.4 Data Trace Interface* are not applicable.
* It is an ambition to extract single, shared *RISC-V Trace Ingress Port* specifications (combining this chapter with relevant E-Trace chapter). 

Table below provides a detailed mapping of encodings of instructions into *itype* signal - it should be used during development of ingress port logic inside of a hart. Please be aware that not only instructions, but also arguments matter (for example jalr rd,rs1 may generate 5  different, distinct *itype* values).

[#Generating itype for different instructions]
.Generating itype for different instructions
[cols="25%,40%,35%",options="header",]
|======================================================================================================
|Instruction Retired|Condition/Notes|itype Value
|Interrupted instruction|Any instruction|2 = Interrupt
|Exception in instruction|Any instruction|1 = Exception
|Conditional branch|Non-taken                               |4 = Non-taken branch
||Taken                                   |5 = Taken branch
|ebreak, ecall, c.ebreak|ecall is reported after retirement |1 = Exception
|mret, sret, uret|                                          |3 = Exception or interrupt return
|cm.jt          |Defined by Zcmt extension                  |0 = No special type
|non-jump|                                                  |0 = No special type
3+|*Values of itype (4-bit) needed for <<Implicit Return Optimization,Implicit Return Optimization>>*
|jal rd         |rd = `link`                                |9 = Inferable call
|               |rd != `link`                               |15 = Other inferable jump
|jalr rd, rs1   |rd = `link` and rs1 != `link`              |8 = Uninferable call
|               |rd = `link` and rs1 = `link` and rd != rs1 |12 = Coroutine swap
|               |rd = `link` and rs1 = `link` and rd = rs1  |8 = Uninferable call
|               |rd != `link` and rs1 = `link`              |13 = Return
|               |rd != `link` and rs1 != `link`             |14 = Other uninferable jump
|c.jal          |Implicit x1                                |9 = Inferable call
|c.jalr rs1     |rs1 = x5                                   |12 = Coroutine swap
|               |rs1 != x5                                  |8 = Uninferable call
|c.jr rs1       |rs1 = `link`                               |13 = Return
|               |rs1 != `link`                              |14 = Other uninferable jump
|c.j            |No registers, only offset                  |15 = Other inferable jump
|cm.jalt        |Defined by Zcmt extension                  |9 = Inferable call
|cm.popret*     |Defined by zcmp extension                  |13 = Return
3+|*Values of itype (3-bit) without <<Implicit Return Optimization,Implicit Return Optimization>>*
|jal rd         |                                           |0 = No special type
|jalr           |                                           |6 = Uninferable jump
|c.j or c.jal   |                                           |0 = No special type
|cm.jalt        |Defined by Zcmt extension                  |0 = No special type
|cm.popret*     |Defined by Zcmp extension                  |6 = Uninferable jump
|======================================================================================================

[NOTE]
====
* Branches (*itype*=4, 5) are conditional direct branches. In RISC-V ISA all jumps, calls, returns are always unconditional.
* Symbol `link` means register *x1* or *x5* as specified in *The RISC-V Instruction Set Manual, Volume I: Unprivileged ISA* document.
* 4-bit *itype* (codes 8..15) are only necessary when <<Implicit Return Optimization,Implicit Return Optimization>> is implemented.
* Tail calls defined as allowed *itype* (values 10 and 11) in  <<E-Trace_Specification,E-Trace Specification>> cannot be distinguished from normal direct/indirect unconditional jumps and as such are impossible to be generated by a hart (unless someone implements <<Custom Instructions,Custom Instructions>>).
====

Table below defines how N-Trace encoder should handle different 3-bit *itype* values on trace ingress port.

[#Handling of 3-bit itype values]
.Handling of 3-bit itype values
[cols="7%,23%,60%",options="header",]
|======================================================================================================
|#|itype|Encoder Action
|0|None below|Only update <<field_I-CNT,I-CNT>> field.
|1|Exception|Update <<field_I-CNT,I-CNT>> field. +
Emit Indirect Branch message with <<field_B-TYPE,B-TYPE>>=2 or 1. +
*IMPORTANT:* An address emitted is known at the next ingress port cycle.
|2|Interrupt|Update <<field_I-CNT,I-CNT>> field. +
Emit Indirect Branch message with <<field_B-TYPE,B-TYPE>>=3 or 1. +
*IMPORTANT:* An address emitted is known at the next ingress port cycle.
|3|Exception or interrupt return|Update <<field_I-CNT,I-CNT>> field. +
Emit Indirect Branch message with <<field_B-TYPE,B-TYPE>>=0. +
*IMPORTANT:* An address emitted is known at the next ingress port cycle.
|4|Non-taken branch|*For BTM mode:* +
  Only update <<field_I-CNT,I-CNT>> field.

*For HTM mode:* +
  Update <<field_I-CNT,I-CNT>> field. +
  Add 0 as LSB bit to HIST field. See <<HIST Field Overflows, HIST Field Overflows>> for handling of overflow.
|5|Taken branch|*For BTM mode:* +
  Update <<field_I-CNT,I-CNT>> field. +
  Generate <<msg_DirectBranch,DirectBranch>> message.

*For HTM mode:* +
Update <<field_I-CNT,I-CNT>> field. +
Add 1 as LSB bit to HIST field. See <<HIST Field Overflows, HIST Field Overflows>> for handling of overflow.
|6|Un-inferable jump|Update <<field_I-CNT,I-CNT>> field. +
Emit Indirect Branch message with <<field_B-TYPE,B-TYPE>>=0. +
*IMPORTANT:* An address emitted is known at the next ingress port cycle.
|7|Reserved|-
|======================================================================================================

When ingress port is implemented as 4-bit, the general un-inferable jump *itype=6* should not be generated and one of the following values should be generated instead. Encode must handle call stack as described in the <<Implicit Return Optimization,Implicit Return Optimization>> chapter.

[#Handling of 4-bit itype values]
.Handling of 4-bit itype values
[cols="7%,23%,58%,12%",options="header",]
|======================================================================================================
|8|Un-inferable call|Update <<field_I-CNT,I-CNT>> field. Emit Indirect Branch message with <<field_B-TYPE,B-TYPE>>=0|Push
|9|Inferrable call|Only update <<field_I-CNT,I-CNT>> field.|Push
|10|Un-inferable tail-call|*NOT POSSIBLE* (see <<Custom Instructions,Custom Instructions>>)|-
|11|Inferrable tail-call|*NOT POSSIBLE* (see <<Custom Instructions,Custom Instructions>>)|-
|12|Co-routine swap|Update <<field_I-CNT,I-CNT>> field. +
If Pop returns the same address as PC at next ingress port cycle, emit Indirect Branch message with <<field_B-TYPE,B-TYPE>>=0.|Pop,Push
|13|Return|Update <<field_I-CNT,I-CNT>> field. +
If Pop returns the same address as PC at next ingress port cycle, emit Indirect Branch message with <<field_B-TYPE,B-TYPE>>=0.
|Pop
|14|Other un-inferable jump|Update <<field_I-CNT,I-CNT>> field. +
Emit Indirect Branch message with <<field_B-TYPE,B-TYPE>>=0.|-
|15|Other inferable jump|Only update <<field_I-CNT,I-CNT>> field.|-
|======================================================================================================

As almost every ingress port cycle is updating I-CNT it may overflow. See <<I-CNT Field Overflows, I-CNT Field Overflows>> for more details.

NOTE: If optional <<trTeInstEnAllJumps,trTeInstEnAllJumps>> bit is set, trace ingress port must report *itype*=5 (Taken branch) for all direct unconditional jumps (which are normally reported as *itype* = 0). It is also possible (for implementation of both ingress port inside of a core and N-Trace encoder) to use reserved *itype*=7 for that purpose - in such a case trace encoder should handle *itype*=7 as value 0 or 5. 

IMPORTANT: N-Trace encoder does not require *cause* and *tvar* ingress port signals (valid for exceptions and interrupts only) as these are not reported in N-Trace messages. N-Trace is only providing the address of an exception/interrupt handler.

== N-Trace Transmission Protocol

The Nexus standard defines a trace messaging protocol using a number of *MDO* (Message Data Out) signals and one or two flag signals known as *MSEO* (Message Start/End Out). A Nexus message is sent or stored in a record composed of *MDO* and *MSEO*. 

N-Trace specification defines 6-bit *MDO* and 2-bit *MSEO* so both fit in a single byte.

* It allows easy storage in memory as well as sending using 1-bit/ 2-bit/ 4-bit/ 8-bit/ 16-bit parallel transport (which is supported by many existing trace probes and connectors).
* Decoding software may work on bytes and 32-bit/64-bit words and expect MSEO bits at two LSB bits of each byte.

N-Trace messages transmission protocol is a strict subset of Nexus trace messaging protocol.

[cols="33%,22%,45%",options="header",]
|====
|Protocol Feature|Defined in Nexus IEEE 5001|N-Trace (strict subset of Nexus)
|Number of *MSEO* bits|1 or 2|2
|Number of *MDO* bits|At least 1|6
|Total (*MDO*+*MSEO*) bits|At least 2|8 (one byte)
|Order (transmitted or stored)|Vendor defined|*MSEO* before *MDO*, each LSB first
|Max field size|Not specified|64 bits (some 32 bits or less)
|Max message size|Not specified|38 bytes (worst sum of all fields)
|====

Max message size (38 bytes) is calculated for <<msg_IndirectBranchHistSync,IndirectBranchHistSync>> message which includes TCODE/ SRC/ SYNC/ B-TYPE(5 bytes total), I-CNT(30 bits, 5 bytes), F-ADDR(63 bits, 11 bytes), HIST(32 bits, 6 bytes) TSTAMP(64 bits, 11 bytes).

* Particular hardware may provide a smaller limit (usually I-CNT is smaller), but always must assure that internal FIFOs must be designed to hold at least two longest messages.
* Decoding software may avoid allocating dynamic memory, but every conforming decoder must survive any size of message as trace memory may be corrupted (trace with all 0-s may be considered as a very long variable-length field).

=== MSEO Sequences

*MSEO[1:0]* bits (on LSB part of each byte) are defined by the follow rules:

* The first byte of a message sends the LSBs of the message and is indicated by *MSEO[1:0]=00*.
* The last byte of a variable-length field is indicated by *MSEO[1:0]=01*.
** A variable-length field in a message always ends on a byte boundary (zero extended as needed).
** Bytes occupied by fixed-length fields and initial parts of longer variable-length fields are sent using *MSEO[1:0]=00*.
* The last byte of a message is indicated by *MSEO[1:0]=11*.
**It also implies an end of the last (fixed-length or variable-lenght) field of a message.
* Idle bytes (between messages or used as padding) are indicated by *MSEO[1:0]=11* and *MDO[5:0]=111111* (entire byte is *0xFF*).
* Value of *MSEO[1:0]=10* is reserved for future extensions.

Table below provides possible sequences of *MSEO[1:0]* bits (to expand above rules - *highlighted* MSEO represent the actuation function): 

[#MSEO Transitions]
.Allowed MSEO Transitions
[cols="30%,30%",options="header",]
|====
|MSEO Function|Dual MSEO[1:0] Sequence
|Start of message|11s-*00*
|End of message|00 (or 01)-*11*-(more 11s)
|End of variable-length field|00 (or 01)-*01*
|Message transmission|*00* s
|Idle (no message)|*11* s
|Reserved|any-*10*
|====

[NOTE]
====
Original Nexus specification defines the MSEO protocol as follows:

* Two `1`-s followed by one `0` indicates the start of a message.
* `0` followed by two or more `1`-s indicates the end of a message.
* `0` followed by `1` followed by `0` indicates the end of a variable-length field.
* `0`-s at all other clocks during transmission of a message.
* `1`-s at all clocks during no message transmission (idle).

Dual MSEO protocol (utilized by this N-Trace specification) is a subset of this general (single and dual) MSEO protocol definition.
====

=== Unified N-Trace Message Structure

Each N-Trace message has identical structure (100% compatible with Nexus):

* Very first field is ALWAYS fixed-length *TCODE* (Transport Code) which defines the meaning and format of subsequent fields.
* In case of simultaneous tracing from more than one hart, the second field is ALWAYS fixed-length *SRC* (Message Source) field, which provides a unique ID of message source.
** This field allows trace decoders to separate messages from different trace sources (Trace Encoders, harts) without knowing any details of each of the messages.
** This method can be used to handle different (opaque) trace or debug or performance data using N-Trace transport/storage/export infrastructure. 
* One or more (fixed-length or variable-length) payload fields. Sequence and selection of these fields depend on the value of *TCODE* field.
** In some rare cases one of preceding fields may define number of following fields.
* Very last field is (optional) variable-length *TSTAMP* (Timestamp) field.   
** It may be possible to generate and analyze timestamps in a unified (simpler) way.

=== Order of bits and bytes

Order of bits and bytes:

* Trace messages/packets are considered as sequences of bytes and are always transmitted with LSB bits/bytes first.
* Nexus MSEO bits are transmitted on the LSB part and bit#0 first.
* Idle state must be transmitted as all MSEO and MDO bits = 1.
* For transmission on a 16bit interface (e.g. PIB 16-bit mode), the first byte of message/packet is transmitted on the LSB part and the MSEO of the second/odd byte is transmitted on bits #8-#9 and MDO on bits #10-#15.

NOTE: Above rules allow receiving trace probes to skip idle messages.

=== PIB Idle Cycles Explained

This chapter describes N-Trace specific details about the transmission via a Pin Interface Block (PIB), as it is described in the <<RISC-V_Trace_Control_Interface,RISC-V Trace Control Interface>> Specification.

Trace messages may start on any (positive or negative) edge of trace clock. 

IMPORTANT: Once a message is started all bits of that message must be transmitted on consecutive trace clock edges (both positive and negative).

Said so, an idle sequence may be sent using any number of trace clock edges (positive or negative).

To explain this let's assume the following serially transmitted (in 1-bit PIB mode) sequences of bits (MSEO[0] bit being first on the left):

* < `11` DDDDDD> - 8 bits in a last byte of a message (`11` = MSEO, DDDDDD = DATA bits)
* < `1*n` >      - sequence of `n`-bits long idle bits (each must be `1`)
* < `00` TTTTTT> - 8 bits in a first byte of a message (`00` = MSEO, TTTTTTT = TCODE bits)

The following 4 example sequences:

* ... < `11` DDDDDD> < `00` TTTTTT> ...           => No idle bits/cycles between consecutive messages.
* ... < `11` DDDDDD> < `1*2` > < `00` TTTTTT> ... => Two (even) idle bits.
* ... < `11` DDDDDD> < `1*3` > < `00` TTTTTT> ... => Three (odd) idle bits (second message starts at another trace clock edge).
* ... < `11` DDDDDD> < `1*8` > < `00` TTTTTT> ... => 8 idle bits (idle sequence can be considered as byte 0xFF).

are all valid.

NOTE: Some implementations may always send idle sequences using even (or even multiple of 8) number of trace clocks - in such a case all packets will always start on a positive or negative trace clock. But conformant trace probes must handle any number of idle clocks.

NOTE: The trace probe needs to be able to synchronize with the trace stream and to detect where the trace message boundaries are. This procedure is sometimes referred to as "message alignment synchronization" or "alignment-sync". Nexus or N-Trace does not need a dedicated alignment-sync sequence, but instead Nexus idle sequences can be used for alignment-sync with PIB. This means that some trace probes can only perform alignment-sync on a PIB trace stream, if the stream does contain Nexus idle sequences at some point (i.e. if not all trace messages arrive back-to-back).

=== N-Trace Message Example

Table below shows one N-Trace message with several fields. It is an output from N-Trace dump tool (part of N-Trace reference C code) with an added *Explanation* column.

[#MDO_MSEO Examples]
.MDO and MSEO Encoding Example
[cols="7%,10%,8%,30%,45%",options="header",]
|====
|Byte|MDO [5:0]|MSEO [1:0]|Decoded (by reference tool)|Explanation
|0xFF| 111111|11 | Idle | Most likely idle, but can also be the last byte of the previous message.
|0x70| 011100|00 | TCODE[6] = 28 - IndirectBranchHist| First byte, all 6 MDO bits have TCODE.
5+|Here we could have an SRC field (it would shift the start of B-TYPE).
|0xD0| 110100|00 | BTYPE[2] = 0x0| This is a 2-bit (fixed-length) field. As B-TYPE is a fixed-length field, four MSB bits are part of the next field (I-CNT).
|0x1D| 000111|01 | ICNT[10] = 0x7D| This is a second byte of the 7-bit (0x7D) variable-length I-CNT field. Here three MSB bits are all 0-s to assure that the variable-length field uses all 6 MDO bits.
|0x1D| 000111|01 | UADDR[6] = 0x7| This is a single byte variable-length U-ADDR field (with three MSB 0-s bits).
|0xF8| 111110|00 || Normal transfer of new field (6 LSB bits).
|0xFF| 111111|11 | HIST[12] = 0xFFE| Last byte of message. It implies the end of the 12-bit HIST field. In this field we do not have any extra 0-bits on MSB.
5+|Here we could have TSTAMP field (previous MSEO should became 01, what means end of field, but not end of message)
|0xFF| 111111|11 | Idle|This is idle as this is the second byte with MSEO=11 (NOTE: Last byte of message is also 0xFF).
|====

== N-Trace Specific Trace Controls

This chapter describes how fields and bits from Trace Encoder control registers (named using *trTe...* pattern) are influencing N-Trace encoder and N-Trace protocol messages. N-Trace specific clarifications, in addition to description in <<RISC-V_Trace_Control_Interface,RISC-V Trace Control Interface>> specification are provided. 

NOTE: The table below does not provide names of Trace Encoder control registers as names of bits/fields used in Trace Control Interface are unique.

[#Details_Control_Parameters]
.Trace Encoder Parameters and Controls
[cols="30%,17%,53%",options="header",]
|======================================================================================================
|Trace Control Bit/Field|Applicability|Description
|trTeActive |*Required*|See <<RISC-V_Trace_Control_Interface,RISC-V Trace Control Interface>> Specification.
|trTeEnable |*Required*|See <<RISC-V_Trace_Control_Interface,RISC-V Trace Control Interface>> Specification.
|trTeInstTracing |*Required*|See <<RISC-V_Trace_Control_Interface,RISC-V Trace Control Interface>> Specification.
|trTeEmpty |*Required*|See <<RISC-V_Trace_Control_Interface,RISC-V Trace Control Interface>> Specification.
[[trTeInstMode]]
|trTeInstMode |*Required*|One or more of the following values: +
*3:* <<mode_BTM,BTM>> (Branch Trace Messaging) mode +
*6:* <<mode_HTM,HTM>> (History Branch Messaging) mode +
must be allowed.
[[trTeContext]]
|trTeContext|Optional|Controls generation of <<msg2_Ownership,Ownership>> messages.
|trTeInstTrigEnable |Optional|See <<RISC-V_Trace_Control_Interface,RISC-V Trace Control Interface>> Specification.
|trTeInstStallOrOverflow |*Required*|See <<RISC-V_Trace_Control_Interface,RISC-V Trace Control Interface>> Specification.
|trTeInstStallEna |Optional|See <<RISC-V_Trace_Control_Interface,RISC-V Trace Control Interface>> Specification.
[[trTeInhibitSrc]]
|trTeInhibitSrc|Optional|Controls generation of <<field_SRC,SRC>> field.
[[trTeInstSyncMode]]
|trTeInstSyncMode |*Required*|Controls generation of <<Synchronization Messages,Synchronization Messages>> (with <<field_SYNC,SYNC>> field=2). May be hard-coded to non-0.
[[trTeInstSyncMax]]
|trTeInstSyncMax |*Required*|Controls generation of <<Synchronization Messages,Synchronization Messages>> (with <<field_SYNC,SYNC>> field=2). May be hard-coded.
|trTeFormat |*Required*|Must be set to *1* (which denotes N-Trace format).
|trTeVerMajor |*Required*|See <<RISC-V_Trace_Control_Interface,RISC-V Trace Control Interface>> Specification.
|trTeVerMinor |*Required*|See <<RISC-V_Trace_Control_Interface,RISC-V Trace Control Interface>> Specification.
|trTeCompType |*Required*|See <<RISC-V_Trace_Control_Interface,RISC-V Trace Control Interface>> Specification.
[[trTeProtocolMajor]]
|trTeProtocolMajor|*Required*|*Must be 1* to encode this version (1.0) of N-Trace protocol. *Value different than 1 is considered a non-compatible version and must be rejected.*
[[trTeProtocolMinor]]
|trTeProtocolMinor|*Required*|*Must be 0* to encode this version (1.0) of N-Trace protocol. *Different values are considered as down-compatible extensions as should be accepted by trace tool.* Any future non-compatible feature should be specifically enabled (by new control bits), so older tools (which never set these new bits) should work with it.
|trTeInstNoAddrDiff|Not applicable|Must be hard-coded as *0*.
|trTeInstNoTrapAddr|Not applicable|Must be hard-coded as *0*.
[[trTeInstEnSequentialJump]]
|trTeInstEnSequentialJump|Optional|See <<Sequential Jump Optimization,Sequential Jump Optimization>> chapter.
[[trTeInstEnImplicitReturn]]
|trTeInstEnImplicitReturn|Optional|See <<Implicit Return Optimization,Implicit Return Optimization>> chapter.
|trTeInstEnBranchPrediction|Not applicable|Must be hard-coded as *0*.
|trTeInstEnJumpTargetCache|Not applicable|Must be hard-coded as *0*.
[[trTeInstImplicitReturnMode]]
|trTeInstImplicitReturnMode|Optional|See <<Implicit Return Optimization,Implicit Return Optimization>> chapter.
[[trTeInstEnRepeatedHistory]]
|trTeInstEnRepeatedHistory|Optional|See <<Repeated History Optimization,Repeated History Optimization>> chapter.
[[trTeInstEnAllJumps]]
|trTeInstEnAllJumps|Optional|See <<RISC-V_Trace_Control_Interface,RISC-V Trace Control Interface>> Specification.
[[trTeInstExtendAddrMSB]]
|trTeInstExtendAddrMSB|Optional|See <<Virtual Addresses Optimization, Virtual Addresses Optimization>> chapter.
[[trTeSrcID]]
|trTeSrcID|Optional|Controls generation of <<field_SRC,SRC>> field.
[[trTeSrcBits]]
|trTeSrcBits|Optional|Controls generation of <<field_SRC,SRC>> field.
|trTeInstFilters|Optional|See <<RISC-V_Trace_Control_Interface,RISC-V Trace Control Interface>> Specification.
|trTeDataImplemented|Future|*Must be 0* as Nexus data trace messages are not part of version 1.0 of N-Trace specification.
|*Other* trTeData...|Future|As Nexus defines data trace messages, future versions of N-Trace may allow these (as an optional extension).
|*All* trTeTrig...|Optional|See <<RISC-V_Trace_Control_Interface,RISC-V Trace Control Interface>> Specification.
|*All* trTeFilter...|Optional|See <<RISC-V_Trace_Control_Interface,RISC-V Trace Control Interface>> Specification.
|*All* trTeComp...|Optional|See <<RISC-V_Trace_Control_Interface,RISC-V Trace Control Interface>> Specification.
|======================================================================================================

[[trTsEnable]]
NOTE: Bit *trTsEnable* (part of potentially shared Timestamp Unit) controls generation of <<field_TSTAMP,TSTAMP>> fields in N-Trace messages. See <<RISC-V_Trace_Control_Interface,RISC-V Trace Control Interface>> Specification for details of the Timestamp Unit.

== Main N-Trace Trace Modes

Nexus standard defined two main modes of tracing program flow:

[[mode_BTM]]
* *BTM (Branch Trace Messaging)* - every taken direct conditional branch is generating at least two byte message, but repeated branches may be counted and reported as a single message with a count (instead of many identical messages).

[[mode_HTM]]
* *HTM (Branch History Messaging)* - every direct conditional branch (taken or not-taken) adds a single bit to the history buffer. It is much more efficient. 

Encoder must implement at least one of these modes, however it is unlikely both HTM and BTM modes will be available.

IMPORTANT: The Nexus standard defines different conformance levels. These levels are not directly applicable to N-Trace as Nexus levels always include debug levels. Different N-Trace options are provided in <<N-Trace Specific Trace Controls,N-Trace Specific Trace Controls>> chapter.

== N-Trace Messages (Overview)

IMPORTANT: Names `Indirect Branch ...` used by Nexus standard may be confusing as RISC-V ISA only allows direct conditional (and always relative) branches. Also RISC-V ISA is differentiating jumps (unconditional flow changes) and branches (conditional flow changes), while in Nexus terminology any flow change (including exceptions/interrupts) are always named as branches. This specification is using term 'branch' and 'jump' as defined in RISC-V ISA. 

// [#Fields in Messages]
=== Fields in Messages

Table below shows all types of messages. Single row shows all fields in particular message type. Many messages share fields and these fields are always present in the same order.

Attributes of fields is described as follows:

* *[n]* means *n*-bit (fixed-length) field
* *[Var]* means variable-length, at least 1-bit wide, field
* *[Cfg]* means configurable field (existence and size of this field depends on the encoder configuration option)

.Fields in Messages
[cols="26%,9%,7%,7%,9%,17%,8%,10%,7%",options="header",]
|===========================================================================================
| Message ID/Field [size]|<<field_TCODE,TCODE>> [6]|<<field_SRC,SRC>> [Cfg]|<<field_SYNC,SYNC>> [4]|<<field_B-TYPE,B-TYPE>> [2]|Other fields|<<field_I-CNT,I-CNT>> [Var]|<<Address Compression,x-ADDR>> [Var]|<<field_HIST,HIST>> [Var]
|[[msg_Ownership]]<<msg2_Ownership,Ownership>>   |2    |Cfg|    |     |<<field_PROCESS,PROCESS>> *[Var]*        |    |     |
|[[msg_DirectBranch]]<<msg2_DirectBranch,DirectBranch>>          |3    |Cfg|    |     |                  |Yes |     |
|[[msg_IndirectBranch]]<<msg2_IndirectBranch,IndirectBranch>>        |4    |Cfg|    |Yes  |                  |Yes |<<field_U-ADDR,U-ADDR>>|
|[[msg_Error]]<<msg2_Error,Error>>                 |8    |Cfg|    |     |<<field_ETYPE,ETYPE>> *[4]* + <<field_ECODE,ECODE>> *[Var]*  |    |     |
|[[msg_ProgTraceSync]]<<msg2_ProgTraceSync,ProgTraceSync>>         |9    |Cfg|Yes |     |                  |Yes |<<field_F-ADDR,F-ADDR>>|
|[[msg_DirectBranchSync]]<<msg2_DirectBranchSync,DirectBranchSync>>      |11   |Cfg|Yes |     |                  |Yes |<<field_F-ADDR,F-ADDR>>|
|[[msg_IndirectBranchSync]]<<msg2_IndirectBranchSync,IndirectBranchSync>>    |12   |Cfg|Yes |Yes  |                  |Yes |<<field_F-ADDR,F-ADDR>>|
|[[msg_ResourceFull]]<<msg2_ResourceFull,ResourceFull>>          |27   |Cfg|    |     |<<field_RCODE,RCODE>> *[4]* + <<field_RDATA,RDATA>> *[Var]*|    |     |
|[[msg_IndirectBranchHist]]<<msg2_IndirectBranchHist,IndirectBranchHist>>    |28   |Cfg|    |Yes  |                  |Yes |<<field_U-ADDR,U-ADDR>>|Yes
|[[msg_IndirectBranchHistSync]]<<msg2_IndirectBranchHistSync,IndirectBranchHistSync>>|29   |Cfg|Yes |Yes  |                  |Yes |<<field_F-ADDR,F-ADDR>>|Yes
|[[msg_RepeatBranch]]<<msg2_RepeatBranch,RepeatBranch>>          |30   |Cfg|    |     |<<field_B-CNT,B-CNT>> *[Var]*           |    |     |
|[[msg_ProgTraceCorrelation]]<<msg2_ProgTraceCorrelation,ProgTraceCorrelation>>  |33   |Cfg|    |     |<<field_EVCODE,EVCODE>> *[4]* + <<field_CDF,CDF>> *[2]* |Yes |     |*Cfg*
|<<msg_other,Vendor Defined>>|56..62|Cfg 6+| Vendor defined message (dedicated Nexus *TCODE* range)
|<<msg_other,Reserved>>|other|Cfg 6+| Reserved for future extensions of N-Trace specification
|===========================================================================================

IMPORTANT: Any message may include the optional <<field_TSTAMP,TSTAMP>> *[Var,Cfg]* field as the very last field of a message (it is not shown in above table because of lack of space). It must be enabled by <<trTsEnable,trTsEnable>> control bit. Timestamp field always starts at byte-boundary (as it is always preceded by variable-length field). See <<Timestamp Reporting,Timestamp Reporting>> chapter for more details. 

[[msg_other]]
Messages marked as *Reserved* or *Vendor Defined* should be ignored by decoders interested in program flow only.
However decoders should provide an option to display/dump them and/or generate a warning as such a message may be seen when trace capture is corrupted.
*Vendor Defined* messages can be used for prototyping, debugging, validation and maintenance purposes.

Reference code header https://github.com/riscv-non-isa/tg-nexus-trace/blob/master/refcode/c/NexRvMsg.h defines all messages in machine-readable format:

[source,c]
----
  NEXM_BEG(IndirectBranchSync, 12),
    NEXM_FLD(SYNC, 4),
    NEXM_FLD(BTYPE, 2),
    NEXM_VAR(ICNT),
    NEXM_ADR(FADDR),
    NEXM_VAR(TSTAMP),
  NEXM_END(),

  NEXM_BEG(ResourceFull, 27),
    NEXM_FLD(RCODE, 4),
    NEXM_VAR(RDATA),
    NEXM_VAR(TSTAMP),
  NEXM_END(),

  NEXM_BEG(IndirectBranchHist, 28),
    NEXM_FLD(BTYPE, 2),
    NEXM_VAR(ICNT),
    NEXM_ADR(UADDR),
    NEXM_VAR(HIST),
    NEXM_VAR(TSTAMP),
  NEXM_END(),
----

NOTE: Reference code is using plain C-style identifiers, so the field name as *B-TYPE* will become *BTYPE*.

=== Common Fields

Table below provides details for fields which are used in more than one message type. Fields which are present in only one message are described with each message. 

.Details of Common Fields
[cols="10%,7%,18%,65%",options="header",]
|======================================================================================================
| Name | Bits | Description | Values/Notes
4+|*Fields used in many messages*
[[field_TCODE]]
| TCODE      | 6             | Transfer Code | Message header that identifies the number and/or size of fields to be transferred, and how to interpret each of the fields following it. Table
[[field_SRC]]
| SRC        | *Cfg* | Source of Message Transmission | Width of SRC field is defined by <<trTeSrcBits,trTeSrcBits>> control field and it may be enabled/disabled by <<trTeInhibitSrc,trTeInhibitSrc>> control bit. This optional field is used to identify the source of the message transmission. In configurations that comprise only a single hart, this field need not be transmitted. For processors that comprise multiple harts, this field must be transmitted as part of the message to identify the source of the message transmission. Within a given device, the SRC field bit size should be the same size across all trace encoders associated with same trace stream.
[[field_SYNC]]
| SYNC       | 4             |Reason for Synchronization| Encodings and details are provided in <<Synchronization Messages,Synchronization Messages>> chapter.

NOTE: The SYNC field is always sent together with the <<field_F-ADDR,F-ADDR>> field, so decoding may start from this message.
[[field_B-TYPE]]
| B-TYPE      | 2             | Branch Type | Reason for indirect flow change: +
                                *0:* Standard: Indirect control flow change (jump, call or return). +
                                *1:* Standard: Exception or interrupt (if the encoder is not capable of reporting 2 and 3). +
                                *2:* *Extension:*: Exception +
                                *3:* *Extension:*: Interrupt +
                                NOTE: Either 1-only or both 2 and 3 should be implemented and consistently reported. Extended values 2 and 3 allow trace tools to distinguish exceptions and interrupts easily.
[[field_I-CNT]]
| I-CNT       | *Var* | Instruction Count | As RISC-V allows variable-length instructions, this is a number of 16-bit half-instructions executed/retired since the I-CNT counter was transmitted or reset.  See <<I-CNT Details,I-CNT Details>> chapter for more details.
[[field_F-ADDR]]
| F-ADDR      | *Var* | Full Target Address | Full PC address (LSB bit, which is always 0 for RISC-V is skipped).
See <<Address Compression,Address Compression>> chapter for more details.

 NOTE: The F-ADDR field is always sent together with the <<field_SYNC,SYNC>> field.
[[field_U-ADDR]]
| U-ADDR      | *Var* | Unique part of Target Address | Unique part of PC address (XOR with recent x-ADDR drop).
See <<Address Compression,Address Compression>> chapter for more details.

The U-ADDR field is always sent together with the <<field_B-TYPE,B-TYPE>> field.
[[field_HIST]]
| HIST       | *Var* | Direct Branch History map |  MSB = 1 is 'stop-bit', LSB denotes the last direct conditional branch. See <<HIST Field Generation,HIST Field Generation>> chapter for more details. 
[[field_TSTAMP]]
| TSTAMP     | *Var* | Timestamp (optional) | Either absolute or relative timestamp value. It must be enabled by <<trTsEnable,trTsEnable>> control bit. See <<Timestamp Reporting,Timestamp Reporting>> chapter for more details.
|======================================================================================================

Original Nexus specification does not define limits for variable-length fields, but N-Trace provides some limits. It will help to write efficient decoding software but is not limiting hardware in any way.

[#Max_Field_Sizes]
.Maximum Field Sizes
[cols="22%,30%,8%,50%",options="header",]
|======================================================================================================
|Field|Symbol|Bits|Description
[[NTRACE_MAX_SRC]]
|SRC|NTRACE_MAX_SRC|12|Determined by size of Trace Control register field. Enough for 4096 (4K) trace sources.
[[NTRACE_MAX_ICNT]]
|I-CNT|NTRACE_MAX_ICNT|22|Usually a smaller value will be sufficient. MSB bit serves as overflow marker and I-CNT overflow must be generated when it is set.
[[NTRACE_MAX_ADDR]]
|F-ADDR, U-ADDR|NTRACE_MAX_ADDR|63|LSB bit is always 0 for RISC-V addresses so 63 bits only.
[[NTRACE_MAX_HIST]]
|HIST|NTRACE_MAX_HIST|32|It includes stop-bit. This size is optimal for not wasting any bits in very often used <<msg_ResourceFull,ResourceFull>> messages.
[[NTRACE_MAX_TSTAMP]]
|TSTAMP|NTRACE_MAX_TSTAMP|64|It is certainly big enough. It corresponds to architecture defined timer and cycle count registers.
|======================================================================================================

== N-Trace Messages (Details)

This chapter provides a detailed description of all N-Trace messages. Overview of all fields in all messages is provided in the <<Fields in Messages,Fields in Messages>> table above.

Common fields are described in the <<Common Fields,Common Fields>> chapter, but fields specific to particular message *TCODE* are explained here.

Size of field in *Bits* column may be one or more of the following values:

* *n (1..6)* - This is an *n*-bits wide, fixed-length field.
* *Var* - This is a variable-length, at least 1-bit wide field.
* *Cfg* - Size of this field depends on configuration setting (*Cfg* fields are always optional).
* *Opt* - This field is optional (depends on the value of one of the preceding fields).

Each message has its own table showing all fields in that message.

IMPORTANT: Original Nexus specification is showing tables with *TCODE* (which is sent first) in the last row. This specification shows <<Fields in Messages,Fields in Messages>> in order of sending them (the first field sent is described first). This is consistent with storage, processing and text dump order.

[[msg2_Ownership]]
=== Ownership Message

This message provides necessary context (privileged mode and Context ID assigned by operating system or hypervisor) allowing the decoder to associate program flow with different parts of code which belong to different programs. It must be explicitly enabled by the <<trTeContext,trTeContext>> control bit. It is reported in one of these three conditions:

* When an instruction which is changing privilege mode or *scontext/hcontext* CSR is executed.
* Immediately following any trace <<Synchronization Messages,synchronization message>> (any message that includes the <<field_SYNC,SYNC>> field).
** If *hcontext* is implemented two messages must follow (first providing *hcontext* and second providing *scontext*). It is necessary so the decoder will be able to locate the code for a specific process. 
* At entry and returns to/from exceptions and interrupts (as these are usually changing privilege modes).

[#Fields_Ownership]
.Ownership Message Fields
[cols="10%,13%,77%",options="header",]
|======================================================================================================
|Bits|Name|Description
|6   |TCODE            |Value=2(0x2). Standard Transfer Code (<<field_TCODE,TCODE>>) field.
|Cfg |SRC              |Standard Message Source (<<field_SRC,SRC>>) field.
[[field_PROCESS]]
|Var |PROCESS          |This is a variable-length field, which encodes *V* and *PRV* privilege mode bits as well as *scontext/hcontext* CSR values. Details are provided below.
|Var,Cfg |TSTAMP       |Standard Timestamp (<<field_TSTAMP,TSTAMP>>) field.
|======================================================================================================

*Explanations and Notes* 

Field PROCESS is encoded as 4 sub-fields (FORMAT, PRV, V, CONTEXT). Bit layout can be defined in RTL-like syntax as follows:

 PROCESS[x+5:0] = {CONTEXT[x:0], V[0], PRV[1:0], FORMAT[1:0]}

.Encoding of PROCESS field (in LSB to MSB bit-order)
[cols="35%,20%,12%,8%,25%",options="header",]
|======================================================================================================
|Reason|FORMAT[1:0]|PRV[1:0]|V[0]|CONTEXT[x:0]
| V or PRV change |00   |Yes|Yes|--
| Reserved  |01|--|--|--
| Sync or *scontext* change |10|Yes|Yes|*scontext* value
| Sync or *hcontext* change |11|Yes|Yes|*hcontext* value
|======================================================================================================

Encodings of *V/PRV* follow ISA privilege mode encodings and are encoded as follows:

 U-mode:     V=0, PRV[1:0]=00
 S-mode:     V=0, PRV[1:0]=01
 M-mode:     V=0, PRV[1:0]=11
 VU-mode:    V=1, PRV[1:0]=00
 VS-mode:    V=1, PRV[1:0]=01

All unused encodings are reserved.

Examples:

 PROCESS=0x3B2 = 0b11101_1_00_10   => scontext=0x1D,V=1,PRV[1:0]=00  (VU-mode) 
 PROCESS=0xC           0b0_11_00   => V=0,PRV[1:0]=11                (M-mode) 

[[msg2_DirectBranch]]
=== DirectBranch Message

This message is generated when the taken direct conditional branch has retired. It is applicable to <<mode_BTM,BTM>> mode only.

[#Fields_DirectBranch]
.Direct Branch Message Fields
[cols="10%,13%,77%",options="header",]
|======================================================================================================
|Bits|Name|Description
|6   |TCODE            |Value=3(0x3). Standard Transfer Code (<<field_TCODE,TCODE>>) field.
|Cfg |SRC              |Standard Message Source (<<field_SRC,SRC>>) field.
|Var |I-CNT            |Standard Instruction Count (<<field_I-CNT,I-CNT>>) field.
|Var,Cfg |TSTAMP       |Standard Timestamp (<<field_TSTAMP,TSTAMP>>) field.
|======================================================================================================

*Explanations and Notes* 

Last instruction in the code block (or blocks) with all inferable instructions (described by I-CNT) is a taken, direct conditional branch instruction. Next PC is determined by taking [+-]offset (from the opcode of that direct conditional branch instruction) and adding it to an address of direct conditional branch instruction.

NOTE: Non-taken direct conditional branches or direct unconditional jumps are NOT generating any trace but increase I-CNT (and direct unconditional jumps are changing PC to direct unconditional jump destination address), so PC of last instruction in code block[s] can be found.

[[msg2_IndirectBranch]]
=== IndirectBranch Message

This message is generated when an instruction causing indirect unconditional control flow change has retired (or interrupt/exception happened) It is applicable to <<mode_BTM,BTM>> mode only.

[#Fields_IndirectBranch]
.Indirect Branch Message Fields
[cols="10%,13%,77%",options="header",]
|======================================================================================================
|Bits|Name|Description
|6   |TCODE            |Value=4(0x4). Standard Transfer Code (<<field_TCODE,TCODE>>) field.
|Cfg |SRC              |Standard Message Source (<<field_SRC,SRC>>) field.
|2   |B-TYPE           |Standard Branch Type (<<field_B-TYPE,B-TYPE>>) field.
|Var |I-CNT            |Standard Instruction Count (<<field_I-CNT,I-CNT>>) field.
|Var |U-ADDR           |Standard Unique Address (<<field_U-ADDR,U-ADDR>>) field.
|Var,Cfg |TSTAMP       |Standard Timestamp (<<field_TSTAMP,TSTAMP>>) field.
|======================================================================================================

*Explanations and Notes* 

Last instruction in the code block (or blocks) (described by HIST and I-CNT fields) is an indirect unconditional control flow change (jump, call, return) instruction or this packet is generated when exception or interrupt is reported in the ingress port. Next PC is determined by the XOR of the U-ADDR field with the recent address being transmitted (either as F-ADDR or as U-ADDR). See <<Address Compression,Address Compression>> chapter for more details.

NOTE: Not-taken direct conditional branches or direct unconditional jumps are NOT generating any trace but increase I-CNT (and direct unconditional jumps are changing PC to direct unconditional jump destination address), so PC of last instruction in code block[s] can be found.

[[msg2_Error]]
=== Error Message

[#Fields_Error]
.Error Message Fields
[cols="10%,13%,77%",options="header",]
|======================================================================================================
|Bits|Name|Description
|6   |TCODE            |Value=8(0x8). Standard Transfer Code (<<field_TCODE,TCODE>>) field.
|Cfg |SRC              |Standard Message Source (<<field_SRC,SRC>>) field.
[[field_ETYPE]]
|4   |ETYPE            |Error type. Subset of standard Nexus encoding: +
*0:* Standard: Queue Overrun caused messages (one or more) to be lost. +
*1..7:* Standard: Reserved. +
*8..15:* Standard: Reserved for Vendor Defined Error(s).
[[field_ECODE]]
|Var     |ECODE        |Error code. Subset of standard Nexus encoding (set of bits) +
 *0:* Exact reason unknown/not-provided. +
 *xxxxxxx1:*   Standard: Reserved. +
 *xxxxxx1x:*   Standard: Reserved (for data trace in future). +
 *xxxxx1xx:*   Standard: Program Trace Message(s) lost. +
 *xxxx1xxx:*   Standard: Ownership Trace Message(s) lost. +
 *xxx1xxxx:*   Standard: Reserved. +
 *xx1xxxxx:*   Standard: Reserved (for data trace in future). +
 *x1xxxxxx:*   Standard: Reserved. +
 *1xxxxxxx:*   Standard: Vendor Defined Message(s) lost. +
*IMPORTANT:* Implementation may always report this field as 0. It is important to have this field ALWAYS generated as it assures that the TSTAMP field will start at the byte boundary.
|Var,Cfg |TSTAMP       |Standard Timestamp (<<field_TSTAMP,TSTAMP>>) field.
|======================================================================================================

*Explanations and Notes*

Error Message must be sent immediately prior to a <<Synchronization Messages,synchronization message>> as soon as space is available in the Trace Encoder output queue. It should be time-stamped at the moment when the trace messages got dropped.

[NOTE]
====
This message *is required* as otherwise decoder (despite the fact that restart after FIFO overflow is signaled) would not be aware that trace was lost in case of the following sequence of events:

* Trace is turned off by trigger (or from any other reason).
* Message reporting 'trace off' event is lost (due to lack of space for it).
* Trace is never restarted.
* Trace is stopped (this will not generate any trace as trace is turned off)
====

[[msg2_ProgTraceSync]]
=== ProgTraceSync Message

[#Fields_ProgTraceSync]
.Program Trace Synchronization Message Fields
[cols="10%,13%,77%",options="header",]
|======================================================================================================
|Bits|Name|Description
|6   |TCODE            |Value=9(0x9). Standard Transfer Code (<<field_TCODE,TCODE>>) field.
|Cfg |SRC              |Standard Message Source (<<field_SRC,SRC>>) field.
|4   |SYNC             |Standard Synchronization Reason (<<field_SYNC,SYNC>>) field.
|Var |I-CNT            |Standard Instruction Count (<<field_I-CNT,I-CNT>>) field.
|Var |F-ADDR           |Standard Full Address (<<field_F-ADDR,F-ADDR>>) field.
|Var,Cfg |TSTAMP       |Standard Timestamp (<<field_TSTAMP,TSTAMP>>) field.
|======================================================================================================

*Explanations and Notes*

This message is generated at start/restart of trace. I-CNT field must be 0 in such a case. However, for some values of SYNC (like `External Trace Trigger`), I-CNT field may not be 0 and may be used to identify the exact PC location when that particular trigger/event happened. Field F-ADDR provides a full PC address.

[[msg2_DirectBranchSync]]
=== DirectBranchSync Message

[#Fields_DirectBranchSync]
.Direct Branch with Sync Message Fields
[cols="10%,13%,77%",options="header",]
|======================================================================================================
|Bits|Name|Description
|6   |TCODE            |Value=11(0xB). Standard Transfer Code (<<field_TCODE,TCODE>>) field.
|Cfg |SRC              |Standard Message Source (<<field_SRC,SRC>>) field.
|4   |SYNC             |Standard Synchronization Reason (<<field_SYNC,SYNC>>) field.
|Var |I-CNT            |Standard Instruction Count (<<field_I-CNT,I-CNT>>) field.
|Var |F-ADDR           |Standard Full Address (<<field_F-ADDR,F-ADDR>>) field.
|Var,Cfg |TSTAMP       |Standard Timestamp (<<field_TSTAMP,TSTAMP>>) field.
|======================================================================================================

*Explanations and Notes*

This message is generated in the same conditions as <<msg2_DirectBranch,DirectBranch>> message, but additionally provides a reason for synchronization (SYNC field) and full PC (F-ADDR field).

[[msg2_IndirectBranchSync]]
=== IndirectBranchSync Message

[#Fields_IndirectBranchSync]
.Indirect Branch with Sync Message Fields
[cols="10%,13%,77%",options="header",]
|======================================================================================================
|Bits|Name|Description
|6   |TCODE            |Value=12(0xC). Standard Transfer Code (<<field_TCODE,TCODE>>) field.
|Cfg |SRC              |Standard Message Source (<<field_SRC,SRC>>) field.
|4   |SYNC             |Standard Synchronization Reason (<<field_SYNC,SYNC>>) field.
|2   |B-TYPE           |Standard Branch Type (<<field_B-TYPE,B-TYPE>>) field.
|Var |I-CNT            |Standard Instruction Count (<<field_I-CNT,I-CNT>>) field.
|Var |F-ADDR           |Standard Full Address (<<field_F-ADDR,F-ADDR>>) field.
|Var,Cfg |TSTAMP       |Standard Timestamp (<<field_TSTAMP,TSTAMP>>) field.
|======================================================================================================

*Explanations and Notes*

Last instruction in the code block (or blocks) (described by HIST and I-CNT fields) is an indirect unconditional control flow change (jump, call, return) instruction or this packet is generated when exception or interrupt is reported in the ingress port. Next PC is provided as an F-ADDR field in this message.

NOTE: Not-taken direct conditional branches or direct unconditional jumps are NOT generating any trace but increase I-CNT (and direct unconditional jumps are changing PC to direct unconditional jump destination address).

[[msg2_ResourceFull]]
=== Resource Full Message

This message is emitted when the HIST mask or I-CNT counter has reached maximum value for particular encoder implementation.

[#Fields_ResourceFull]
.Resource Full Message Fields
[cols="10%,13%,77%",options="header",]
|======================================================================================================
|Bits|Name|Description
|6   |TCODE            |Value=27(0x1B). Standard: Transfer Code (<<field_TCODE,TCODE>>) field.
|Cfg |SRC              |Standard Message Source (<<field_SRC,SRC>>) field.
[[field_RCODE]]
|4   |RCODE            |Standard Resource Code field (defines a meaning of RDATA fields). +
*0:* Standard: I-CNT counter has overflowed and is reported in the RDATA[0] field. +
*1:* Standard: HIST field has overflowed and is reported in the RDATA[0] field. +
*2*: *Extension:* HIST field has overflowed and is repeated. RDATA[0] field holds HIST value and RDATA[1] field holds HREPEAT (History Repeat) value. This optional extension can be enabled via the <<trTeInstEnRepeatedHistory,trTeInstEnRepeatedHistory>> control bit. +
*3..7:* Standard: Reserved for future encodings. +
*8..15:* Standard: Reserved for vendor specific encodings.
[[field_RDATA]]
|Var|RDATA [0]         |Standard: For RCODE=0, this is the I-CNT field. For RCODE=1 this is the HIST field (with MSB=1 being stop-bit). +
*Extension:* For RCODE=2 this is the HIST field (with MSB=1 being stop-bit).
|Var,Opt|RDATA [1]     |*Extension:* When RCODE=2 is reported this field includes HREPEAT (History Repeat) count.
|Var,Cfg |TSTAMP       |Standard Timestamp (<<field_TSTAMP,TSTAMP>>) field.
|======================================================================================================

*Explanations and Notes*

* I-CNT value (with RCODE=0) will be reported with the MSB bit in the <<NTRACE_MAX_ICNT,NTRACE_MAX_ICNT>>-bit counter. It is just a simple counter, but when MSB bit is set a message with overflown I-CNT should be generated.
** See <<I-CNT Field Overflows,I-CNT Field Overflows>> chapter for more details.
* Not repeated HIST field overflow (RCODE=1) will usually include the longest supported by a particular encoder HIST field.
** However any number of HIST bits may be transmitted (from 2 to <<NTRACE_MAX_HIST,NTRACE_MAX_HIST>> bits).
* RCODE = 2: See <<Repeated History Optimization,Repeated History Optimization>> chapter for more details about this optional extension.
* Both I-CNT and HIST may overflow at the same time - in such a case two Resource Full messages must be generated (in any order, however it is suggested to report I-CNT overflow first).

[[msg2_IndirectBranchHist]]
=== IndirectBranchHist Message

[#Fields_IndirectBranchHist]
.Indirect Branch History Message Fields
[cols="10%,13%,77%",options="header",]
|======================================================================================================
|Bits|Name|Description
|6   |TCODE            |Value=28(0x1C). Standard Transfer Code (<<field_TCODE,TCODE>>) field.
|Cfg |SRC              |Standard Message Source (<<field_SRC,SRC>>) field.
|2   |B-TYPE           |Standard Branch Type (<<field_B-TYPE,B-TYPE>>) field.
|Var |I-CNT            |Standard Instruction Count (<<field_I-CNT,I-CNT>>) field.
|Var |U-ADDR           |Standard Unique Address (<<field_U-ADDR,U-ADDR>>) field.
|Var |HIST             |Standard Branch History (<<field_HIST,HIST>>) field.
|Var,Cfg |TSTAMP       |Standard Timestamp (<<field_TSTAMP,TSTAMP>>) field.
|======================================================================================================

*Explanations and Notes* 

Last instruction in the code block (or blocks) (described by HIST and I-CNT fields) is an indirect unconditional control flow change (jump, call, return) instruction or this packet is generated when exception or interrupt is reported in the ingress port. See <<HIST Field Generation,HIST Field Generation>> and <<I-CNT Details,I-CNT Details>> chapters for clarifications.

Next PC (after indirect unconditional jump or exception/interrupt handler) is determined by the XOR of the U-ADDR field with the recent address being transmitted (either as F-ADDR or as U-ADDR). See <<Address Compression,Address Compression>> chapter for more details.

[[msg2_IndirectBranchHistSync]]
=== IndirectBranchHistSync Message

[#Fields_IndirectBranchHistSync]
.Indirect Branch History with Sync Message Fields
[cols="10%,13%,77%",options="header",]
|======================================================================================================
|Bits|Name|Description
|6   |TCODE            |Value=29(0x1D). Standard Transfer Code (<<field_TCODE,TCODE>>) field.
|Cfg |SRC              |Standard Message Source (<<field_SRC,SRC>>) field.
|4   |SYNC             |Standard Synchronization Reason (<<field_SYNC,SYNC>>) field.
|2   |B-TYPE           |Standard Branch Type (<<field_B-TYPE,B-TYPE>>) field.
|Var |I-CNT            |Standard Instruction Count (<<field_I-CNT,I-CNT>>) field.
|Var |F-ADDR           |Standard Full Address (<<field_F-ADDR,F-ADDR>>) field.
|Var |HIST             |Standard Branch History (<<field_HIST,HIST>>) field.
|Var,Cfg |TSTAMP       |Standard Timestamp (<<field_TSTAMP,TSTAMP>>) field.
|======================================================================================================

*Explanations and Notes* 

Last instruction in the code block (or blocks) (described by HIST and I-CNT fields) is an indirect unconditional control flow change (jump, call, return) instruction or this packet is generated when exception or interrupt is reported in the ingress port. See <<HIST Field Generation,HIST Field Generation>> and <<I-CNT Details,I-CNT Details>> chapters for clarifications.

Next PC (after indirect unconditional jump or exception/interrupt handler) is provided as an F-ADDR field. See <<Address Compression,Address Compression>> chapter for more details.

[[msg2_RepeatBranch]]
=== RepeatBranch Message

[#Fields_RepeatBranch]
.Repeat Branch Message Fields
[cols="10%,13%,77%",options="header",]
|======================================================================================================
|Bits|Name|Description
|6   |TCODE            |Value=30(0x1E). Standard Transfer Code (<<field_TCODE,TCODE>>) field.
|Cfg |SRC              |Standard Message Source (<<field_SRC,SRC>>) field.
[[field_B-CNT]]
|Var |B-CNT            |Standard Branch Count field.
Number of times the previous branch message is repeated. Generated if I-CNT, HIST and target address is the same as in the previous branch message.
|Var,Cfg |TSTAMP       |Standard Timestamp (<<field_TSTAMP,TSTAMP>>) field.
|======================================================================================================

*Explanations and Notes* 

This message is reported when an identical branch message is encountered (just to save trace bandwidth). Trace decoder should just repeat handling of previous branch message B-CNT times.

[[msg2_ProgTraceCorrelation]]
=== ProgTraceCorrelation Message

This message is emitted when the trace is disabled or stopped.

[#Fields_ProgTraceCorrelation]
.Program Trace Correlation Message Fields
[cols="10%,13%,77%",options="header",]
|======================================================================================================
|Bits|Name|Description
|6   |TCODE            |Value=33(0x21). Standard Transfer Code (<<field_TCODE,TCODE>>) field.
|Cfg |SRC              |Standard Message Source (<<field_SRC,SRC>>) field.
[[field_EVCODE]]
|4   |EVCODE           |Reason to generate Program Correlation: +
                            *0:* Standard: Entry into Debug Mode. Required (do not send 4 instead!). +
                            *1:* Standard: Entry into Low-power Mode. Optional. +
                            *2..3:* Standard: Reserved for data trace. +
                            *4:* Standard: Program Trace Disabled (hart is still running). Optional. +
                            *5..7:* Standard: Reserved for future extensions of N-Trace specification. +
                            *8..15:* Standard: Reserved for vendor specific encodings.
[[field_CDF]]
|2   |CDF              |Define number of CDATA fields following it: +
                            *0:* Standard: Only I-CNT field follows and there is no HIST field. +
                            *1:* Standard: I-CNT field and single CDATA (HIST) field (for HTM trace). +  
                            *2..3:* Standard: Reserved for future extensions of N-Trace specification. +
*IMPORTANT:* IN BTM trace mode CDF must be 0. In HTM trace mode CDF must be 1 (even if HIST is empty=0x1).
|Var |I-CNT            |Standard Instruction Count (<<field_I-CNT,I-CNT>>) field.
|Var,Cfg |HIST         |Standard Branch History (<<field_HIST,HIST>>) field. *This field must be present in HTM mode* so decoder does not need to read CDF to determine it's existence.
|Var,Cfg |TSTAMP       |Standard Timestamp (<<field_TSTAMP,TSTAMP>>) field.
|======================================================================================================

*Explanations and Notes* 

It provides a reason (in EVCODE field) plus I-CNT and HIST fields, which allows the decoder to determine the PC where an execution or the trace actually stopped.

== Field Encoding and Calculation Techniques

This chapter describes in detail how key fields (I-CNT, HIST, U-ADDR/F-ADDR and TSTAMP) are calculated and encoded.

=== Address Compression

Address transmissions is compliant with the Nexus specification (MSB 0-s skipped) with optional extension allowing to skip identical MSB bits (following Sv39/Sv48/Sv57 address generation rules). See <<Virtual Addresses Optimization, Virtual Addresses Optimization>> chapter below for clarifications.

Key rules when generating addresses:

* Only execution addresses (as seen by the hart) are reported. In case MMU is enabled these are virtual addresses.
* Address fields are being sent beginning with bit 1 since all execution addresses are on 2-byte boundaries (LSB bit always 0).
* Addresses sent in <<field_U-ADDR,U-ADDR>> compressed form are computed based on a reference address sent by or computed from the most recent preceding message containing an address field. 
* Starting with an <<field_F-ADDR,F-ADDR>>, each U-ADDR modifies the reference address used for the next address. 
* A U-ADDR is generated by XORing the full address with the reference address and sending the result starting with bit 1 and with high-order zeroes suppressed.
* The reverse process is used by trace decoder to calculate the original full address. 

Example:

[#Address XOR Compression]
.Address XOR Compression Example
[cols="10%,35%,44%,11%",options="header",]
|====
|Address    |U-ADDR XOR calculations        |F-ADDR/U-ADDR field sent            |   New REF Address
|0x3FC04    |                               |F-ADDR=1_1111_1110_0000_0010=0x1FE02|   0x3FC04
|0x3F368    | REF =0011_1111_1100_0000_0100 +
              addr=0011_1111_0011_0110_1000 +
              XOR =0000_0000_1111_0110_1100 |U-ADDR=111_1011_0110=0x7B6            |   0x3F368
|0x3E100    | REF =0011_1111_0011_0110_1000 +
              addr=0011_1110_0001_0000_0000 +
              XOR =0000_0001_0010_0110_1000 |U-ADDR=1001_0011_0100=0x934           |   0x3E100
|====

=== Virtual Addresses Optimization

This optimization must be enabled by <<trTeInstExtendAddrMSB,trTeInstExtendAddrMSB>> control bit. 

NOTE: Normally (without above bit enabled or implemented) addresses with many MSB bits=1 will be send as long packets (as variable size fields skip MSB=0 only). The following address *0xFFFF_FFFF_8000_31F4* (real address from Linux kernel) will be encoded as *F-ADDR=0x7FFF_FFFF_C000_18FA* (LSB 0-bit skipped). Such 63-bit variable field value will require 11 bytes to be sent (as we have 6 MDO bits in each byte).

The following additional rules are used (when <<trTeInstExtendAddrMSB,trTeInstExtendAddrMSB>> control bit is implemented and set):

. If F-ADDR/U-ADDR field is sent then last (MSB) bit of the very last MDO record must be extended up to bit#63 or bit#31 (depending of XLEN of the core). It is similar to sign-extension, but it is NOT a sign bit.
. This method does NOT require trace decoder to know what is a size of virtual address or if an address is physical or virtual. Decoder must look at MSB bit of last MDO in F-ADDR/U-ADDR field and either extend or not.
. Simple implementations may not implement an enable bit and always send full address.  
.. Benefits of using it on 32-bit cores is small, so it may not be implemented.  

IMPORTANT: Trace encoder must implement a MSB extension (skipping identical 1-s or 0-s in addition to skipping identical 0-s as for any other variable size field) while sending U-ADDR field. Trace decoders must do it in reverse order, which means that a sign extension (if needed) must be done after collecting the last MDO bit in an U-ADDR field. Calculation of full address (as defined in <<Address Compression,Address Compression>> chapter above) must be done after sign extension of U-ADDR field.

==== Example Encodings

*Non-extended address (MSB MDO bit = 0)*

            MDO_MSEO
 #byte:  543210        <- MDO bit index (bit#5 is MSB)
  -------------------
    #0:  111111_00
    #1:  111111_00
    #2:  111111_00
    #3:  111111_00
    #4:  111111_00
    #5:  011111_01     <- Last MDO+MSO byte. MSB bit #5 is 0, so NO extension.
                       F-ADDR field=0x7_FFFF_FFFF, Encoded address=0xF_FFFF_FFFE

*Extended address (MSB MDO bit = 1)*

            MDO_MSEO
 #byte:  543210        <- MDO bit index (bit#5 is MSB)
  -------------------
    #0:  111111_00
    #1:  111111_00
    #2:  111111_00
    #3:  111111_00
    #4:  011111_00
    #5:  111100_01     <- Last MDO+MSEO byte. MSB bit #5 is 1, so WITH extension.
                       F-ADDR field=0xF_1FFF_FFFF, Encoded address=0xFFFF_FFFE_3FFF_FFFE

*Non-extended address (extra MDO with all 0-s prevents extension)*

            MDO_MSEO
 #byte:  543210        <- MDO bit index (bit#5 is MSB)
  -------------------
    #0:  111111_00
    #1:  111111_00
    #2:  111111_00
    #3:  111111_00
    #4:  111111_00
    #5:  111111_00
    #6:  000000_01     <- Last MDO+MSEO byte. MSB bit #5 is 0, so NO extension.
                       F-ADDR field=0xF_FFFF_FFFF, Encoded address=0x1F_FFFF_FFFE

*Non-extended full 64-bit address (invalid address)*

            MDO_MSEO
 #byte:  543210        <- MDO bit index (bit#5 is MSB)
  -------------------
    #0:  111111_00
    #1:  111111_00
    #2:  111111_00
    #3:  111111_00
    #4:  111111_00
    #5:  111111_00
    #6:  111111_00
    #7:  111111_00
    #8:  111111_00
    #9:  111111_00
   #10:  000101_01     <- Last MDO+MSEO byte. MSB bit #5 is 0, so NO extension.
                       F-ADDR field=0x5FFF_FFFF_FFFF_FFFF, Encoded address=0xBFFF_FFFF_FFFF_FFFE

NOTE: Address *0xBFFF_FFFF_FFFF_FFFF* is NOT a legal address in any Sv39/Sv48/Sv57 modes as it does not have all MSB bits identical. But such an address may be encountered as result of a bug and as such should be reported.

==== Rationale

RISC-V ISA defines 3 different virtual memory addressing modes: Sv39, Sv48 and Sv57. Privilege ISA specification says:

* For Sv39 => must have bits 63-39 all equal to bit 38
* For Sv48 => must have bits 63-48 all equal to bit 47
* For Sv57 => must have bits 63-57 all equal to bit 56

It means that there is no need to send full 64-bit addresses and report 39, 48 or 57 LSB bits of an address should be enough.

Additionally addresses sent by trace may be one of the following addresses (encoded in F-ADDR/U-ADDR fields as described above)

. Physical address (in M-mode or when MMU is not enabled).
. Virtual address (in S/U-mode when MMU is enabled).
. Any illegal address (for example as result of an return address taken from corrupted stack).

Also, RISC-V System with S and U modes cannot use any physical memory above 56-bit address. This is because of PMP (54-bit field without 2 LSB bits) and Sv39/48/57 limitations (44 bit for page index + 12 bit of page offset).

Some systems may even allow less bits as physical memory map may not have anything above certain (reasonably low) address - this is dictated by simplicity of address decoder and true number of address bits on internal busses.

=== HIST Field Generation

When the encoder is operating in <<mode_HTM,HTM>> mode direct conditional branches do NOT generate any messages. Instead each taken or not-taken direct conditional branch is adding a single bit as LSB bit of HIST field (simple left-shift register). If a direct conditional branch is taken, bit=1 is added at the LSB position. If a direct conditional branch is not-taken, bit=0 is added at the LSB position.

MSB value 1 in the HIST field is used as a stop-bit. It allows the HIST field to be transmitted as a variable-length field efficiently (as MSB=0 bits are not transmitted).

Examples:

 Binary(MSB-LSB):   101=0x5  (two direct conditional branches, not-taken and taken)
 Binary(MSB-LSB):  1111=0xF  (three direct conditional branches, all three taken)
 Binary(MSB-LSB): 10000=0x10 (four direct conditional branches, all four not-taken)
 Binary(MSB-LSB):     1=0x1  (no direct conditional branches at all)

The HIST field is reset (to 1, which is just a stop-bit with no bits encoding direct conditional branches) each time it is transmitted (including when any <<Synchronization Messages,synchronization message>> is transmitted).

As LSB bit encodes the last direct conditional branch, decoders must interpret the HIST field starting from MSB bit (the one before stop-bit = 1). This is the bit which is describing the first encountered (taken or not-taken) direct conditional branch.

==== HIST Field Overflows

The HIST field is usually implemented as a shift register (initialized to 1 at reset). This register is shifted left and 0 or 1 is added to it. When the MSB bit of this register becomes 1, it means that the stop-bit reached the end of the HIST register and HIST field must be sent before next bit can be added.

If this is happening, a <<msg2_ResourceFull,ResourceFull>> with the HIST field (<<field_RCODE,RCODE>>=1 or 2) must be generated.

NOTE: Trace decoders do not have to be aware about the actual size of the HIST field implemented by the encoder, however in order to allow efficient implementation of trace encoders (and also allowing HIST pattern detection) N-Trace implementation limits HIST size to max 32-bits. Longer HIST fields would not provide much gain and are making HIST pattern detection more costly (in terms of hardware resources).

When a HIST buffer is identical in two or more consecutive <<msg2_ResourceFull,ResourceFull>> messages, it can be detected and reported using the HIST + HREPEAT (History Repeat Counter) instead of many identical messages.

See <<Repeated History Optimization,Repeated History Optimization>> chapter for more details.

=== I-CNT Details

Field I-CNT (present in most messages) includes count of 16-bit instruction units reported as retired.

Here are key rules how encoder must calculate I-CNT field:

* Every retired instruction MUST increment I-CNT by 1 (for 16-bit instruction) or by 2 (for 32-bit instruction). Specifically:
** If an instruction is changing the PC, that instruction itself MUST update the I-CNT.
** An exception or interrupt before retirement of an instruction CANNOT update the I-CNT.
** An exception or interrupt after retirement of an instruction MUST update the I-CNT.
** In case of longer instructions (48-bit, 64-bit, ...) (future ISA standards or custom) I-CNT may increment by 3 or more. 
* Reset of I-CNT is described in the <<I-CNT Resets,I-CNT Resets>> chapter below.

==== I-CNT Handling in BTM mode

As an illustration, let's consider the following piece of pseudo-code (... does not matter):

    0x100:  c.add ...       ; Plain linear 16-bit instruction
    0x102:  b... 0x200      ; Direct conditional branch (32-bit instruction)
    0x106:  add ...         ; Plain linear 32-bit instruction
    0x10A:  b... 0x300      ; Direct conditional branch (32-bit instruction)
    0x10E:  c.add ...       ; Plain linear 16-bit instruction
    0x110:  add ...         ; Plain linear 32-bit instruction
    0x114:  c.ebreak        ; 16-bit breakpoint (to stop the code)
    ...
    0x200:  c.add ...       ; Plain linear 16-bit instruction
    0x202:  c.ebreak        ; 16-bit breakpoint (to stop the code)
    ...
    0x300:  add ...         ; Plain linear 32-bit instruction
    0x304:  c.ebreak        ; 16-bit breakpoint (to stop the code)

NOTE: Syntax of address ranges: In the description below a range specified as <0x100..0x105> means that addresses 0x100 and 0x105 are both included in the address range.

Let's assume we start a trace from address 0x100 (<<msg_ProgTraceSync,ProgTraceSync>> with *I-CNT=0* and F-ADDR encoding address = 0x100 should be generated) and let's assume that we executed and collected a trace for above program (in <<mode_BTM,BTM>> mode) three times:

* First time a direct conditional branch at address 0x102 is taken.
** A <<msg_DirectBranch,DirectBranch>> message with *I-CNT=3* should be generated. It means, that a code block from <0x100..0x105> (as 6=2*3) was executed and a direct conditional branch at the end of this block was taken. Decoder will know PC=0x200 from an opcode of the direct conditional branch at an address 0x102.
** Next message should be <<msg_ProgTraceCorrelation,ProgTraceCorrelation>> with *I-CNT=1* describing range <0x200..0x201> till *c.ebreak* instruction
* Second time a direct conditional branch at address 0x102 is not-taken and a direct conditional branch at address 0x10A is taken.
** A <<msg_DirectBranch,DirectBranch>> message with *I-CNT=7* should be generated. It means, that a code block from <0x100..0x10D> (as 0xE=2*7) was executed and a direct conditional branch at the end of this block was taken. Decoder will know PC=0x300 from an opcode of the direct conditional branch at an address 0x10A.
** Next message should be <<msg_ProgTraceCorrelation,ProgTraceCorrelation>> with *I-CNT=2* describing range <0x300..0x303> till *c.ebreak* instruction.
* The third time both direct conditional branches are not-taken.
** In this case only <<msg_ProgTraceCorrelation,ProgTraceCorrelation>> with *I-CNT=10* should be generated.It is describing a range <0x100..0x113> till *c.ebreak* instructions.

NOTE: Decoder must look at each instruction in the code block to know its size. It cannot calculate *current PC+I-CNT*2* as it is UNKNOWN what is the size of the last instruction retired in that block - it may be (compressed) 16-bit or 32-bit (not-compressed) direct conditional branch. Without knowing an instruction size offset of that direct conditional branch cannot be determined.

Above we analyzed some I-CNT values. Let's consider other I-CNT values.

* *I-CNT=1* is the correct value. The only valid reason to generate a message with I-CNT=1 would be an exception (or interrupt) AFTER an instruction at address 0x100. In this case an encoder should generate an <<msg_IndirectBranch,IndirectBranch>> or <<msg_IndirectBranchSync,IndirectBranchSync>> message with I-CNT=1, B-TYPE=1 (exception) and U-ADDR/F-ADDR field encoding an address of an exception/interrupt handler.

* *I-CNT=5* is also correct (which means that exception/interrupt happened before the retirement of an instruction at an address 0x10A).

* *I-CNT=0* is also possible. It should be generated when an interrupt was pending before we started the code (and trace) and instruction at address 0x100 was not executed/retired. Another reason for I-CNT=0 may be a case, where instruction at address 0x100 will generate page fault (prefetch abort) or is illegal. 

* *I-CNT=4 or 6 or 9* are *INCORRECT values* as it would mean that only half of corresponding 32-bit instruction was executed.

IMPORTANT: Decoders must report such incorrect I-CNT values and immediately abort decoding as it means that either an encoder is not conforming to this specification or a trace was captured incorrectly. Decoding may resume at the next <<Synchronization Messages,synchronization message>>, but it is not mandatory for all decoders to do so.

==== I-CNT Handling in HTM mode

When the encoder is operating in <<mode_HTM,HTM>> mode, I-CNT should be incremented at every retired instruction. However direct conditional branches (from code piece above ...) will NOT generate any trace packets, but each of them will add a bit to the HIST field.

Above code may generate messages with the following fields (exact types of messages depend on code not visible in that example):

* I-CNT=4, HIST=0b1_1 (MSB=1 is stop bit, bit pattern '1' means that first direct conditional branch was taken). Encoder should continue from address 0x200 (as the first direct conditional branch encountered was reported as taken) and I-CNT=3 describes a code in <0x100..0x105> (I-CNT=3) and <0x200..0x201> (I-CNT=1) ranges.
* I-CNT=9, HIST=0b1_01 (MSB=1 is stop bit, bit pattern '01' means that first direct conditional branch was not-taken and second direct conditional branch was taken). Encoder should continue from address 0x300 (as the second direct conditional branch encountered was reported as taken)  and I-CNT=2 describes a code in <0x100..0x10D> (I-CNT=7) and <0x300..0x303> (I-CNT=2) ranges.
* I-CNT=10, HIST-0b1_00 (MSB=1 is stop bit, bit pattern '00' means that two direct conditional branches were not-taken). Encoder should continue from address 0x10E  and I-CNT=10 describes a code in <0x100..0x113> range.

NOTE: It is obviously visible that HTM mode provides much better trace compression as trace messages are not generated at every taken direct conditional branch.

==== I-CNT Resets

I-CNT is reset in one of these two situations (as defined by Nexus standard):

* When a trace starts or is restarted (for any reason).
* After I-CNT field is sent in a message (all key messages).

==== I-CNT Field Overflows

When I-CNT field overflows it may be reported in one of two ways:

* In BTM mode (or when the HIST buffer is empty) the <<msg_ResourceFull,ResourceFull>> message with <<field_RCODE,RCODE>>=0 should be generated.
** This message will be generated only when we have a long instruction block or when we have an infinite loop with unconditional direct jump[s].
* In HTM mode and when the HIST buffer is not empty, I-CNT overflow may be reported using a <<Synchronization Messages,synchronization message>> with *SYNC=4 (Sequential Instruction Counter)*.
** First choice (*ResourceFull*) is optional - second choice (*SYNC=4*) can be always generated.

To illustrate *Sequential Instruction Counter* generation let's consider the following example code:

    0x100:  c.add ...       ; Plain linear 16-bit instruction
    0x102:  b... 0x200      ; Direct conditional branch (32-bit instruction)
    0x106:  c.add ...       ; Plain linear 16-bit instruction
    0x108:  add ...         ; Plain linear 32-bit instruction
    0x10c:  add ...         ; Plain linear 32-bit instruction
    0x110:  add ...         ; Plain linear 32-bit instruction
    0x114:  add ...         ; Plain linear 32-bit instruction
    0x118:  add ...         ; Plain linear 32-bit instruction
    0x11C:  c.ebreak        ; 16-bit breakpoint (to stop the code)

and let's assume (just for simplicity) that the I-CNT counter is 4-bit wide (MSB bit being an overflow flag) and that direct conditional branch at an address 0x102 is not-taken (so code will run from address 0x100 till breakpoint at address 0x11C).

Trace of above code should generate 3 messages:

* <<msg2_ProgTraceSync,ProgTraceSync>> (start of trace)
** SYNC=3 (Exit from Debug Mode)
** I-CNT=0 (nothing executed as we are stating)
** F-ADDR=0x80 (encoding starting address 0x100)
* <<msg2_IndirectBranchHistSync,IndirectBranchHistSync>> (I-CNT overflown to 8 after processing address 0x10C)
** SYNC=4 (Sequential Instruction Counter)
** *I-CNT=8* (see note below)
** HIST=0x2 (one not taken direct conditional branch)
** F-ADDR=0x88 (encoding address 0x110)
* <<msg2_ProgTraceCorrelation,ProgTraceCorrelation>> (from address 0x110 till end of trace at 0x11C)
** EVCODE=0 (Entry into Debug Mode)
** CDF=1 (HIST field present after I-CNT)
** *I-CNT=6* (see note below)
** HIST=0x1 (no branches)

[IMPORTANT]
==== 
* Overflown *I-CNT=8* decodes instructions from instruction at an addresses 0x100 to instruction at address 0x10C (16 bytes long address range).
* *I-CNT=6* decodes instructions from addresses 0x110 to 0x118 (12 bytes long address range). Debug Mode is entered before c.ebreak instruction (as it never retires), so c.ebreak is NOT included in I-CNT.  
====

This method should be rather easy to implement as each encoder must implement 'periodic sync' (and may implement triggers as well). These will generate synchronization messages at any moment. The only difference between these would be different values of the SYNC field. It means a lot of already present (and required) logic can be reused.

=== Synchronization Messages

[IMPORTANT]
====
* Trace requires different types of "synchronization" on different abstraction levels. Two major categories of synchronization are:
** *Instruction trace synchronization*: allows the trade decoder to synchronize onto an ongoing instruction trace stream. This is done via Nexus "synchronization messages", which are described in this chapter in more detail.
** *Message alignment synchronization*: allows the trade decoder to detect the trace message boundaries (i.e. start and end of a trace message) within a trace stream. This kind of synchronization is not described in this chapter. It can be done via Nexus idle cycles, and is described in the <<PIB Idle Cycles Explained,PIB Idle Cycles Explained>> chapter in more detail.
====

Synchronization messages provide SYNC code (described below) and full address (field <<field_F-ADDR,F-ADDR>>) and are used to synchronize trace encoder as full PC is provided.

[#SYNC Field Values]
.SYNC Field Values
[cols="10%,20%,10%,10%,50%",options="header",]
|====
|Value|Name |Encoder Reset|Required|Description
|0| External Trace Trigger | *No* | No | This message serves as a marker (encoder state is not reset) of external trigger input. If trace is enabled by a trigger SYNC=5 should be used.
|1| Exit from Reset | Yes | No | Core was reset without stopping (by watchdog for example). Address should be a reset vector, but HIST and I-CNT should provide the PC of the last instruction before reset.
|2| Periodic Synchronization | Yes | Yes | Just periodic instruction trace synchronization (to allow decoding the trace from the middle or when it was wrapped around). The interval for periodic instruction trace synchronization gets configured via <<trTeInstSyncMode,trTeInstSyncMode>> and <<trTeInstSyncMax,trTeInstSyncMax>>.
|3| Exit from Debug Mode |  Yes | Yes | Very first synchronization message after exit from debug mode (unless trace starts disabled - see next chapter).
|4| Sequential Instruction Counter | *No* | Yes/No | Generated when I-CNT overflows. See <<I-CNT Field Overflows,I-CNT Field Overflows>> chapter for details. Required for HTM mode.
|5| Trace Enable |  Yes | No | Generated when trace is re-enabled after a gap caused by trace being disabled (e.g. due to trace filters). This must not be used for exit from debug mode (in which case SYNC=3 must be used).
|6| Trace Event | *No* | No | Serves as a marker (encoder state is not reset) when debug watchpoint with action=4 triggered .
|7| Restart from FIFO overrun |  Yes | Yes |First synchronization after a gap caused by lost trace
|8| Reserved |Yes|-|
|9| Exit from Power-down | Yes | No | When the hart is restarted after powered-down. Similar to SYNC=1 (Exit from Reset) described above.
|10..13| Reserved |Yes|-|
|14..15| Reserved |Yes|-| For vendor defined codes.
|====

Decoders should report different synchronization codes (including reserved codes). Periodic synchronization may only be reported when desired by the user (for debugging?).

[IMPORTANT]
====
* All synchronization messages emit a full <<field_TSTAMP,TSTAMP>> field (if enabled).
* Most synchronization messages fully reset the encoder state, so decoding can be started from this message.
** When trigger is reported (either by debug watchpoint or external trigger) or I-CNT counter overflows, then decoder state is not reset, but still full address and absolute timestamp is reported.
====

=== Corner Cases and Sequences

Normal program flow generates a sequence of messages with I-CNT>0 (reporting at least 1 instruction retired), some HIST fields (to report direct conditional branches) and x-ADDR fields (to report non-inferable unconditional flow changes).

However, sometimes normal flow is interrupted (by exception or interrupt) or some other extra event (trigger/enable/disable) happens and sequence of messages or values of some fields may be a bit unusual. Table below is trying to explain some corner cases. 

[#Corner Cases]
.Corner Cases
[cols="20%,80%",options="header",]
|====
|Sequence of events|Messages Generated
|Back to back return|Second message should have <<field_I-CNT,I-CNT>>=1 or 2 (depending on the size of the second return instruction).
|Other back to back jumps or branches|Same as above (depending on the size of a second instruction)
|Back to back exceptions|Second message with <<field_B-TYPE,B-TYPE>>=2 or 1 (Exception) and <<field_I-CNT,I-CNT>>=0 (nothing executed in between).
|Exception at interrupt destination|Same as above.
|Pending interrupt at start of hart|<<msg2_ProgTraceSync,ProgTraceSync>> with <<field_SYNC,SYNC>>=3 followed by message with <<field_B-TYPE,B-TYPE>>=3 or 1 (Interrupt).
|Exception at first instruction traced|<<msg2_ProgTraceSync,ProgTraceSync>> with <<field_SYNC,SYNC>>=3 followed by a message with <<field_B-TYPE,B-TYPE>>=2 or 1 (Exception).
|Trace starts disabled|<<msg2_ProgTraceCorrelation,ProgTraceCorrelation>> with <<field_EVCODE,EVCODE>>=4 (Trace Disabled). Once trace is enabled message with <<field_SYNC,SYNC>>=5 (Trace Enable).
|Hart stops with trace disabled|<<msg2_ProgTraceCorrelation,ProgTraceCorrelation>> with <<field_EVCODE,EVCODE>>=0 (Enter Debug mode) and <<field_I-CNT,I-CNT>>=0 (nothing executed). 
|====

=== Timestamp Reporting

Timestamp recording must be enabled by <<trTsEnable,trTsEnable>> trace control bit.

If timestamp is enabled all <<Synchronization Messages,synchronization messages>> include an absolute timestamp value with upper zeroes suppressed. Other message types with timestamp emit the timestamp relative to recently reported (absolute or relative timestamp).

NOTE: The TSTAMP field is a variable-length field and MSB bits=0 will not be transmitted. It will provide good compression for relative and absolute timestamps.

To reconstruct the full timestamp, software begins at a <<Synchronization Messages,synchronization message>> and stores the TSTAMP value found there, zero-extended to the full timestamp width. Shortly after starting a trace session, even a 64-bit timestamp will typically require far less than 64 bits to transmit. Software extracts the compressed TSTAMP from each message thereafter and adds it with the previous decompressed timestamp to obtain the full timestamp value associated with this message.

The following rules must be observed:

* If timestamps are enabled, ALL <<Synchronization Messages,synchronization messages>> (which include full address) must include absolute TSTAMP value.
** Otherwise some sections of decoded trace would have a timestamp and some not and it would be hard for a programmer to comprehend such a trace.
* It is permitted that some non-synchronization messages are not reporting timestamp but debugger may not be able to provide profiling data. 
* Absolute timestamp cannot exceed 64 bits (even with 1ps resolution, 64-bit counters will overflow in about 584 years).
** Implementation may choose a smaller counter - trace tools may assume timestamp will not overflow in a single session, however it would not be very hard to add support for it.
* It is suggested that in multi-hart systems all Trace Encoders use a shared timestamp (for better code correlation), but it is not necessary.
* Timestamp at all cases, when an address is provided should be at a time when an event leading to that particular address being sent happened.
** If the above is not possible, timestamps should be at least reported in a consistent way, so distance between distant events can be reliably calculated. 
** It is needed to assure that time reported at exceptions/interrupt handlers will be a moment when exception or interrupt was observed.

== Optional, Optimization Extension to Nexus Standard

N-Trace messages are defined as a strict subset of standard Nexus messages. However in order to provide better compression some optional extensions are defined and must be specifically enabled. Table <<#Details_Control_Parameters,Details_Control_Parameters>> describes all control bits to enable these optimizations.

=== Sequential Jump Optimization

This optimization must be enabled by <<trTeInstEnSequentialJump,trTeInstEnSequentialJump>> control bit.

By default, the target of an indirect unconditional jump is always considered an uninferable PC discontinuity.
However, if the register that specifies the jump target was loaded with a constant then it can be
considered inferable under some circumstances. The hart must identify indirect unconditional jumps with sequentially
inferable targets and provide this information separately to the encoder. The final decision as to
whether to treat the indirect unconditional jump as inferable or not must be made by the encoder. Both the constant
load and the indirect unconditional jump must be traced as adjacent instructions (in same message/packet) in order for the decoder to be able to infer the indirect unconditional jump target.

Jump targets that are supplied via

* an *lui* or *c.lui* (a register which contains a constant), or
* an *auipc* (a register which contains a constant offset from the PC).

Such indirect unconditional jump targets are classified as sequentially inferable if the pair of instructions are retired
consecutively (i.e. the *auipc*, *lui* or *c.lui* immediately precedes the indirect unconditional jump). 

NOTE: The restriction
that the instructions must be retired consecutively is necessary in order to minimize the additional
signals needed between the hart and the encoder, and should have a minimal impact on trace
efficiency as it is anticipated that consecutive execution will be the norm.

=== Implicit Return Optimization

This optimization must be enabled by the <<trTeInstImplicitReturnMode,trTeInstImplicitReturnMode>> control field different than 0.

Although a function return is usually an indirect unconditional jump, most programs return to the
point in the program from which the function was called using a standard calling convention. For
those programs, it is possible to determine the execution path without being explicitly notified
of the destination address of the return. The implicit return mode can result in very significant
improvements in trace encoder efficiency.

Returns can only be treated as inferable if the associated call has already been reported in an earlier
packet. The encoder must ensure that this is the case.

There are 3 possible ways of handling return address stack (values of <<trTeInstImplicitReturnMode,trTeInstImplicitReturnMode>> control field):

*Simple counting (<<trTeInstImplicitReturnMode,trTeInstImplicitReturnMode>>=1)* 

This can be accomplished by utilizing a
counter to keep track of the number of nested calls being traced. The counter increments on calls
and decrements on returns. The counter will not over or underflow, and is reset to 0 whenever a synchronization packet is sent. Returns will be
treated as inferable and will not generate a trace packet if the count is non-zero (i.e. the associated
call was already reported in an earlier packet). Such a scheme is low cost, and will work as long as programs are "well behaved". The encoder will not be able to check that the return address is actually that of the instruction following the associated call. As such, any program that modifies return addresses cannot be traced using this mode with this minimal implementation. Due to these limitations *this is NOT recommented implementation*.

*Stack with Full Addresses (<<trTeInstImplicitReturnMode,trTeInstImplicitReturnMode>>=3)* 

The encoder maintains a stack of expected return addresses (created when call is encountered), and only treat a
return as inferable if the actual return address matches the value on the stack. This is fully robust for all
programs, but is more expensive to implement. In this case, if a return address does not match the
prediction, it must be reported explicitly via a packet. This ensures that the decoder can determine which return is being reported. This method may use shadow stack if implemented by the core.

*Stack with Partial Addresses (<<trTeInstImplicitReturnMode,trTeInstImplicitReturnMode>>=2)* 

Call stack maintained by encoder may not include all addresses, but only keep some LSB part of it and use them to compare if return is matching the call or not. Changes that program making incorrect return will return to address with the same LSB portion are very slim.

IMPORTANT: Decoder does not need to know what is actual depth of the call stack implemented by encoder but for efficiency reasons it should assume max depth. N-Trace implementation should never implement call stack deeper than 32 levels. Such deep calls will be most likely 'broken' by other events/messages (like periodic SYNC).

=== Repeated History Optimization

This optimization must be enabled by the <<trTeInstEnRepeatedHistory,trTeInstEnRepeatedHistory>> control bit.

When a simple loop is executed many times, it either has a direct conditional branch at the start of a loop (which must be 'taken' to terminate the loop) or has a direct conditional branch at the end of the loop (which must be 'taken' to repeat the loop).
In the first case, the direct conditional branch is 'not-taken' most of the time and 'taken' once at the end. In the second case, the direct conditional branch is 'taken' most of the time, but 'not-taken' at the end of the loop.

Long loops in practical programs/functions (memcpy/strcpy/search …) tend to execute many times and many times flow inside the loop is identical. Instead of sending the same history bits many times, repeated patterns can be detected and counted. This is a big saving! As an example, a memcpy of 4MB buffer using 32-bit transfers will execute at least 1M of direct conditional branches and 1M of history bits must be included in trace (it is a lot of trace).

The Nexus standard defines a <<msg_RepeatBranch,Repeat Branch>> message. This message will provide a single <<field_B-CNT,B-CNT>> (Branch Count) field instead of generating many identical <<msg_DirectBranch,Direct Branch>> messages. But this message cannot be used in <<mode_HTM,HTM>> mode as repeated messages (Direct Branch) do not include the HIST field.

In order to allow generation of repeated history of direct conditional branches in HTM mode an extra encoding for <<field_RCODE,RCODE>>=2 in <<msg_ResourceFull,Resource Full>> message is added.

IMPORTANT: It is allowed to generate any sequence of <<msg_ResourceFull,Resource Full>> messages as long as the logically concatenated sequence of (repeated or not ...) HIST bits (excluding MSB stop-bit[s]) is the same.

Tracing of such simple, long loops would benefit from generating special messages/fields which provide counters of taken/not-taken direct conditional branches (in a way similar to <<msg_RepeatBranch,Repeat Branch>> message)

But this approach will not work with more complex code with a conditional statement (or several of them) inside of a loop.

In such a case, it is desired to detect repeated sequences of taken/not-taken direct conditional branches and instead generate many messages with HIST fields, generate a message consisting of a HIST pattern and repeat count.

Let's assume that we have a loop, which generates a long sequence of repeated taken/not-taken, taken/not-taken direct conditional branches. Trace may generate <<msg_ResourceFull,Resource Full>> messages with the following HIST records:

    Msg#1:
        TCODE=27 (ResourceFull)
        RCODE=1 (HIST record overflow is provided as RDATA)
        RDATA=0b1_01_0101_0101_0101_0101_0101_0101_0101 = 0x55555555
                (stop-bit + pattern 01 repeated 15 times)
    Msg#2:
        TCODE=27 (ResourceFull)
        RCODE=1 (HIST record overflow is provided as RDATA)
        RDATA=0b1_01_0101_0101_0101_0101_0101_0101_0101 = 0x55555555
                (stop-bit + pattern 01 repeated 15 times)
    ...
    Msg#10:
        TCODE=27 (ResourceFull)
        RCODE=1 (HIST record overflow is provided as RDATA)
        RDATA=0b1_01_0101_0101_0101_0101_0101_0101_0101 = 0x55555555
                (stop-bit + pattern 01 repeated 15 times)

Instead of generating many messages with identical HIST record, encoder can detect repeated pattern and generate the following single message:

    Msg#1:
        TCODE=27 (ResourceFull)
        RCODE=2 (HIST record overflow is provided as RDATA and 
                repeat count is provided as HREPEAT field)
        RDATA=0b1_01_0101_0101_0101_0101_0101_0101_0101 = 0x55555555
                (stop-bit + pattern 01 repeated 15 times)
        HREPEAT=10  (Repeat Count=10 instead 10 messages)

Above example shows a 2-bit pattern, but using the same technique it can be expanded to any size of pattern. Exact way to detect these patterns is not specified as it does not change encoding of messages. So, it is possible to generate the following, a bit smaller, message:

    Msg#1:
        TCODE=27 (ResourceFull)
        RCODE=2 (HIST record overflow is provided as RDATA and 
                repeat count is provided as HREPEAT field)
        RDATA=0b1_01 = 0x5 (stop-bit + single pattern 01)
        HREPEAT=150 (Repeat Count is bigger, but pattern is smaller)

NOTE: This type of compression (reporting shorter patterns and larger counts) may not be practical as it may save only a little. Trace is compressed a lot already and it really should not matter if we report 150 iterations of a loop in 6 or 7 bytes. Example above is provided to assure that trace encoders must handle this type of trace compression.

NOTE: When HREPEAT field overflows several message with max HREPEAT value should be generated.

== Rules of Generating Messages

This chapter directly mentions 16-bit and 32-bit instructions (from the currently ratified instruction set), but it is applicable to any size being multiple of 16-bit (as main ISA defines).

*Main Rules*

. Plain linear instructions and direct, PC relative, direct unconditional jumps generate no trace.
** These are called inferable instructions, where the next PC can be certainly known from looking at binary code.
. Only direct conditional branches, indirect unconditional flow transfer instructions and exceptions/interrupts generate trace.
** These are called non-inferable instructions, where the next PC cannot be known by looking at binary code.

*Detailed Rules*

. If tracing was disabled and is restarted, a <<msg_ProgTraceSync,ProgTraceSync>> message is generated.
** This message includes the reason for a start (<<field_SYNC,SYNC>> field) and full address (<<field_F-ADDR,F-ADDR>> field).
. Any retired instruction increments <<field_I-CNT,I-CNT>> field (+1 or +2).
. The following types of instructions allow trace decoders to know the next PC (nothing else is done for them).
** Plain linear instruction => PC is at the next instruction (+2 or +4).
** Direct (inferable...) unconditional jump => PC is unconditional jump destination (known from PC and opcode as all unconditional jumps are PC relative).
** Not taken direct conditional branch (in BTM mode) => PC is next instruction (+2 or +4).
. Indirect, unconditional jump instruction is handled as:
** In BTM mode it generates an <<msg2_IndirectBranch,IndirectBranch>> message.
** In HTM mode it generates an <<msg2_IndirectBranchHist,IndirectBranchHist>> message. If the <<field_HIST,HIST>> field is empty <<msg2_IndirectBranch,IndirectBranch>> message may be (optionally) generated instead.
. Direct, conditional branch instruction is handled as:
** In BTM mode it generates a <<msg_DirectBranch,DirectBranch>> message (only if taken).
** In HTM mode it appends a single bit (1=taken or 0=not-taken) into the branch history buffer (<<field_HIST,HIST>> field).
. In case the trace is stopped or disabled, <<msg_ProgTraceCorrelation,ProgTraceCorrelation>> message is generated.
** It included reason (<<field_EVCODE,EVCODE>> field) and <<field_I-CNT,I-CNT>> and (optional) <<field_HIST,HIST>> field, so the last PC can be calculated. 
. In case the generated message includes <<field_I-CNT,I-CNT>>/<<field_HIST,HIST>> fields, the corresponding value is reset.
** In case I-CNT overflows, <<msg_ResourceFull,ResourceFull>> message (with I-CNT before overflow) is generated and I-CNT is reset.
** In case HIST overflows, <<msg_ResourceFull,ResourceFull>> message (with HIST before overflow) is generated and HIST is reset.

*Extended Rules*

These rules are augmenting the above rules if the corresponding configuration setting is set.

. Call and return instructions maintain call stack and if return is matching a call, no trace is generated.
** This optional feature is described in detail in the <<Implicit Return Optimization,Implicit Return Optimization>> chapter.
. By default, the target of an indirect unconditional jump is always considered an uninferable PC discontinuity. However, if the register that specifies the jump target was loaded with a constant
then it can be considered inferable under some circumstances. 
** Such instruction sequences may be detected and in such a case no trace is generated.
** This optional feature is described in detail in the <<Sequential Jump Optimization,Sequential Jump Optimization>> chapter.

=== Custom Instructions

Custom instructions (or any future ratified instructions) which are not changing PC flow do not require any special treatment. Trace decoders should only look at instructions which may change PC flow and treat everything else as plain linear instructions. 

NOTE: Above rule allowed to not change trace decoders after V or Zb extensions were added (as all instructions are plain linear). From all extensions ratified in the last few years only Zcmp and Zcmt extensions include PC changing instructions.

Custom instruction which may change PC should be traced in one of the following ways:

* If the PC just advances to the next instruction, it should be traced as plain linear instruction. Decoder will just advance the PC.
* If the program flow changes as result of a custom instruction, the custom instruction should be traced as an indirect unconditional jump (even if it is actually not an indirect unconditional jump). That way, the destination address will be reported (as F-ADDR or U-ADDR fields). Decoder will change PC to an address specified in this message. In most cases, this approach should not require any adaptation of the trace decoder. 

Such an approach will NOT require changes in trace decoders. To illustrate this let's consider the following piece of code with custom instruction *XYZ*:

    0x100:  add ...         ; Plain linear 32-bit instruction
    0x104:  XYZ             ; Custom conditional branch to 0x200 (it does not matter if direct or indirect ...)
    0x108:  c.add ...       ; Plain linear 16-bit instruction
    0x10A:  c.ebreak        ; 16-bit breakpoint (to stop the code)
    ...
    0x200:  c.add ...       ; Plain linear 16-bit instruction
    0x202:  c.ebreak        ; 16-bit breakpoint (to stop the code)

It can be traced as follows (exact type of messages do not matter):

* Single message (if branch was not taken)
** *I-CNT=5*     => Instruction XYZ did not change the flow and code in range <0x100..0x10A) got executed
* Two messages (if branch was taken)
** *I-CNT=4*, *F-ADDR=0x100* (denote address 0x200)  => Code in range <0x100..0x108) got executed and next PC after instruction XYZ is 0x200
** *I-CNT=1*                                         => Code in range <0x200..0x202) got executed next

NOTE: If custom instruction will generate some other trace (for example some new type of direct conditional branch which may add HIST bit), decoders must be extended to be aware about type of this custom instruction.

=== Pseudo-code of Simple N-Trace Encoder

Code below is a simplified part of actual C-code used by the reference encoder (in C). It defines two functions:

* NTraceEncoderInit(void) - initialize state of encoder
* NTraceEncoderHandleRetired(uint64_t `addr`, uint32_t `flags`) - handle single retired instruction
** `addr` - address of retired instruction
** `info` - information about instruction (type, size, taken/non-taken)

[source,c]
----

// Use N-Trace TCODE messages
#define NEXUS_TCODE_Ownership                     2
#define NEXUS_TCODE_DirectBranch                  3
#define NEXUS_TCODE_IndirectBranch                4
#define NEXUS_TCODE_Error                         8
#define NEXUS_TCODE_ProgTraceSync                 9
#define NEXUS_TCODE_DirectBranchSync              11
#define NEXUS_TCODE_IndirectBranchSync            12
#define NEXUS_TCODE_ResourceFull                  27
#define NEXUS_TCODE_IndirectBranchHist            28
#define NEXUS_TCODE_IndirectBranchHistSync        29
#define NEXUS_TCODE_RepeatBranch                  30
#define NEXUS_TCODE_ProgTraceCorrelation          33

// Functions/macros which encode bits in 'info' (example...)
#define INFO_LINEAR   0x1   // Linear (plain instruction or not-taken BRANCH)
#define INFO_4        0x2   // If not 4, it must be 2 on RISC-V
#define INFO_INDIRECT 0x8   // Possible for most types above
#define INFO_BRANCH   0x10  // Always direct on RISC-V (may have LINEAR too)

#define InfoIsBranchTaken(info) (!((info) & INFO_LINEAR))
#define InfoIsSize32(info)      ((info) & INFO_4)
#define InfoIsBranch(info)      ((info) & INFO_BRANCH)
#define InfoIsIndirect(info)    ((info) & INFO_INDIRECT)

// Function which emit N-Trace packets (all are empty here)
void EmitFix(int nbits, uint32_t value);    // Emit fixed-size field
void EmitVar(uint64_t value);               // Emit variable size field
void EmitEnd();                             // Terminate message

// Encoder configuration options
const bool      enco_opt_branch_history = true;     // Configuration option
const uint32_t  enco_opt_limICNT    = 0x10000;      // Limit of ICNT (max is 6+6+4 bits)    
const uint32_t  enco_opt_limHIST    = 0x40000000;   // Limit of HIST (max is 5*6 bits)   

// Encoder state variables
static uint32_t encoNextEmit = 0;   // TCODE to be emitted next time
static uint32_t encoICNT = 0;       // ICNT accumulated
static uint32_t encoHIST = 1;       // HIST accumulated (MSB is guardian bit)
static uint64_t encoADDR = 0;       // Last emitted address

void NTraceEncoderInit()
{
    encoADDR = 0;
    encoICNT = 0;   // Empty ICNT and HIST
    encoHIST = 1;

    encoNextEmit = NEXUS_TCODE_ProgTraceSync;
}

void NTraceEncoderHandleRetired(uint64_t addr, uint32_t info)
{
    // Optionally emit what was determined previously
    if (encoNextEmit != 0)
    {
        EmitFix(6, encoNextEmit);   // Emit TCODE (as determined)

        // Emit message fields (accordingly ...)
        if (encoNextEmit == NEXUS_TCODE_ProgTraceSync)
        {
            EmitFix(4, 1);          // Emit SYNC=1  (4-bit)
            EmitVar(encoICNT);      // Emit ICNT    (variable)
            EmitVar(addr >> 1);     // Emit FADDR   (variable)
        }
        else if (encoNextEmit == NEXUS_TCODE_IndirectBranchHist || 
                 encoNextEmit == NEXUS_TCODE_IndirectBranch)
        {
            EmitFix(2, 0);                      // Emit BTYPE=0 (2-bit)
            EmitVar(encoICNT);                  // Emit ICNT    (variable)
            EmitVar((encoADDR ^ addr) >> 1);    // Emit UADDR   (variable)

            if (encoNextEmit == NEXUS_TCODE_IndirectBranchHist)
            {
                EmitVar(encoHIST);              // Emit HIST    (variable)
            }
        }
        else if (encoNextEmit == NEXUS_TCODE_DirectBranch)
        {
            EmitVar(encoICNT);                  // Emit ICNT    (variable)
        }

        EmitEnd();  // It will mark last entry with MSEO=11 and flush it

        if (encoNextEmit != NEXUS_TCODE_DirectBranch)
        {
            encoADDR = addr;  // This is new address
        }
        encoNextEmit = 0;   // Only one time

        encoICNT = 0;       // Start from 'empty' ICNT and HIST
        encoHIST = 1;
    }

    // Update ICNT
    uint32_t prevICNT = encoICNT;   // In case ICNT will overflow now, we need to emit previous value ...
    if (InfoIsSize32(info)) encoICNT += 2; else encoICNT += 1;

    // Determine type of packet (only if this is branch or indirect ...)
    if (InfoIsBranch(info))
    {
        if (enco_opt_branch_history)
        {
            // Update branch history buffer (add LSB bit)
            if (InfoIsBranchTaken(info))
                encoHIST = (encoHIST << 1) | 0; // Mark branch as taken
            else
                encoHIST = (encoHIST << 1) | 1; // Mark branch as not-taken
        }
        else
        {
            if (InfoIsBranchTaken(info))
                encoNextEmit = NEXUS_TCODE_DirectBranch;    // Emit destination address (next retired)
            else
                ;   // Not taken branch is considered as linear instruction
        }
    }
    else
    if (InfoIsIndirect(info))
    {
        if (enco_opt_branch_history)
            encoNextEmit = NEXUS_TCODE_IndirectBranchHist;  // Emit destination address (next retired)
        else
            encoNextEmit = NEXUS_TCODE_IndirectBranch;      // Emit destination address (next retired)
    }

    // Optionally emit ICNT overflow
    if (encoICNT > enco_opt_limICNT) // Instruction count overflown ...
    {
        // Emit ResourceFull with ICNT before this instruction
        EmitFix(6, NEXUS_TCODE_ResourceFull);
        EmitFix(4, 0);                          // RCODE=0 (ICNT overflow)
        EmitVar(prevICNT);                      // RDATA=ICNT
        EmitEnd();  // It will mark last entry with MSEO=11 and flush it

        // Set ICNT for this instruction
        if (InfoIsSize32(info)) encoICNT = 2; else encoICNT = 1;
    }

    // Optionally emit HIST overflow
    if (encoHIST & enco_opt_limHIST) // Is HIST buffer overflown?
    {
        // Emit history BEFORE this instruction (remove LSB bit)
        EmitFix(6, NEXUS_TCODE_ResourceFull);
        EmitFix(4, 1);                          // RCODE=1 (HIST overflow)
        EmitVar(encoHIST >> 1);                 // RDATA=HIST
        EmitEnd();  // It will mark last entry with MSEO=11 and flush it

        // Keep single HIST for this branch (guardian | single LSB bit from encoHIST)
        encoHIST = (0x1 << 1) | (encoHIST & 0x1);
    }
}
----

== N-Trace Decoding Guidelines

To decode an N-Trace encoded stream of messages (as any other compressed trace) access to opcodes of instructions which were executed is necessary. This is usually done by providing an ELF file of a program being executed, but it can also be read-out from the target. Three types of information is needed:

. Size of each instruction (16-bit or 32-bit).
. Types of all instructions (as reported via 'itype' signal on trace ingress port).
. For direct unconditional jumps and direct conditional branches an offset (to jump/branch destination) encoded in an opcode.

At the beginning of the trace 'full PC' (<<field_F-ADDR,F-ADDR>> field) is reported. From that moment decoder must follow the code and update PC according to what is provided in messages.

NOTE: In order to provide partial decoding of big trace, 'full PC' is dropped periodically. Periodic 'full PC' drop is also needed to decode trace from small, wrapped around buffers.

=== Decoding Algorithm Principles

Algorithm to reconstruct complete PC flow from N-Trace messages is very simple:

* Handle <<field_HIST,HIST>> field (if available and not 0x1)
** Analyze code from the current PC through inferable unconditional jumps (all types) and direct conditional branches (each direct conditional branch will 'consume' a single bit from the *HIST* field).
** At the end (after the LSB bit from *HIST* is processed), the PC will be after the last direct conditional branch (either taken or not-taken).
* Handle <<field_I-CNT,I-CNT>> field (if available and not 0x0)
** Analyze code from current PC through inferable unconditional jumps (all types) - each encountered direct conditional branch must be treated as not-taken
** Each encountered instruction should subtract 1 or 2 from I-CNT (depending on a size of particular instruction)
** It will reach either non-inferable unconditional jump or I-CNT will become 0 to denote that some other 'event' (like exception, interrupt, trace off, trigger etc.) happened.
* At the last step the <<field_F-ADDR,F-ADDR>> or <<field_U-ADDR,U-ADDR>> field (if available) should be applied. This will be the next PC where analysis of the next trace message should start.
** This is either a destination address of indirect unconditional jump or an address of an exception/interrupt handler.

[NOTE]
=====
* Phrase *inferable unconditional jumps (all types)* include indirect unconditional jumps, which may be inferable.
* Some messages may encode I-CNT and HIST fields under different names (RDATA/CDATA), but meaning and processing is the same.
* Extra fields like SYNC/B-TYPE only provide extra details, but are NOT essential for a decoder to reconstruct the PC flow.
=====

=== Decoding trace from multiple harts

Decoder for specific a hart should only look for messages with SRC for that particular hart. Each encoder for each enabled hart (in same trace stream) must have same 'trTeSrcBits' and different 'trTeSrcID' fields set.

=== Decoding trace of complex systems (Linux etc.)

In case of complex systems, where code consists of several independently built programs and libraries, decoders must be aware of different program images (ELF files) at different locations. <<msg_Ownership,Ownership>> messages should provide enough context. Decoders must be also aware of assignment of *scontext/hcontext* values for programs and processes being traced.

Operating systems may decide to migrate single process to different cores/harts. It may also be the case, when different threads from the same process (sharing code ...) will run in the same time on more than one core/hart.

NOTE: This is not specific to N-Trace - correct tracing of complex, multi-threaded/multi-core systems is not very easy.

=== Decoding self-modifying or JIT (Just In Time compiled) code

Trace encoder is just encoding a stream of instructions passed by ingress port from the hart running it, but decoder must be aware of types of all instructions being executed.
In case of self modifying code (or JIT code), binary image (at moment of execution) must be available to decoder. How this can be done is not in the scope of this specification.

NOTE: This is not specific to N-Trace - every trace system which is compressing execution flow heavily may not handle this case well.

== Nexus Compliance

The Nexus standard provides a lot of flexibility and in general N-Trace can be considered also fully compatible. There is one incompatible, small change:

* Field <<field_ECODE,ECODE>> is variable-length field (to assure TSTAMP field is on byte boundary).

Compatible extensions are described in a dedicated chapter (each of them must be directly enabled).

== Additional Material

=== Trace Bandwidth Considerations

* SRC field (if enabled) may change the otherwise optimal layout of <<Fields in Messages,Fields in Messages>>.

=== Validation Considerations

* Resource Full message with I-CNT overflow is rare and may not be experienced in normal code. Simplest way to generate is to have an infinite loop and (rare) interrupt handler.
** This loop should increment a register or memory location - this value should correspond to total accumulated I-CNT.

=== Potential Future Enhancements

Table below is proposing some future enhancements for Nexus compatible (N-Trace) messages. These were discussed during the development of the N-Trace specification.

[#Future Enhancements]
.Future Enhancements
[cols="25%,18%,57%",options="header",]
|====
|Enhancement|Conformance|Notes
|Instrumentation Data Trace|Nexus Compatible|Very likely (Nexus defines appropriate messages). It will require software to be instrumented by code sending data using trace infrastructure (Arm CoreSight ITM enabled many use-cases).
|Selective Data Trace|Nexus Compatible|Very likely (Nexus defines appropriate messages). It will allow sending some data in response to triggers (from debug module or external).
|Full Data Trace|Nexus Compatible|Likely (E-Trace supports it), but necessary bandwidth may be a problem.
|Smaller field sizes|Nexus Extension|Unlikely (too much of a change). Some of the fields may be made shorter (as not all cases are needed), but it may not be justified.
|System Bus Trace|Nexus Compatible|Likely (Nexus defines appropriate messages and there is a need for more than trace of harts).
|Additional TCODE|Nexus Extension|Possible, but more real-life examples are needed to justify it.
|Single MSEO bit|Nexus Compatible|Unlikely to be considered. It may provide (12.5% instead of 25% MSEO overhead), but it is more complex to handle by both encoder and decoders.
|More MDO bits|Nexus Compatible|Very unlikely to be considered. In order to keep byte alignment, 14 or 22 or 30-bit MDO may be considered. Even 14-bit will cause a lot of 'wasted' bits.
|====

NOTE: Each of the above enhancements should be first prototyped and validated using reference C encoder/decoder.
